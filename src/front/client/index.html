<!DOCTYPE html>
<html lang="en" <%= htmlWebpackPlugin.options.firebugMark %>>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <title><%= htmlWebpackPlugin.options.title %></title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      property="og:image"
      content="https://screenshots.wpmix.net/chrome_2019-03-28_18-55-506746c4c5-44e6-4bb5-89cb-52ce8fabcedf.png"
    />
    <meta http-equiv="refresh" content="3600">
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
      crossorigin="anonymous"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto:400,500,700,900%7CRoboto%20Mono&#038;display=swap&#038;subset=latin%2Ccyrillic"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.1.0/css/all.css"
      integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt"
      crossorigin="anonymous"
    />

    <meta name="google" content="notranslate" />
    <meta property="og:url" content="https://swaponline.io" />
    <!-- ERC20 Tokens hot plug for widget-build (Dont remove this) -->
    <script src="erc20tokens.js"></script>
    <%= htmlWebpackPlugin.options.firebugScript %>

    <style>
      :root {
        --primary:#6144e5;
        --primary-hover: #7371ff;
        --primary-background: rgba(97, 68, 229, 0.1);
        --alternate: #e91db4;
        --alternate-hover:  #ff1fc5;
      }

      body {
        background-color: #f7f7f7;
      }

      .overflowY-default {
        overflow: visible;
      }

      .overflowY-hidden {
        overflow: hidden;
      }

      .overflowY-dashboardView-default {
        overflow: visible;
      }

      .overflowY-dashboardView-hidden {
        overflow: hidden;
      }

      .overflowY-hidden-force {
        overflow: hidden !important;
      }

      @media screen and (min-width: 769px) {
        .overflowY-dashboardView-hidden {
          overflow: visible;
        }
      }
    </style>
    <style>
      .overlay {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        background-color: white;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1000;
      }

      .darkTheme {
        background-color: #222427;
        color: #fff;
      }

      .loader {
        text-align: center;
      }

      .loader img {
        width: 80px;
      }

      .text {
        margin-top: 20px;
        font-size: 16px;
        top: 65%;
        text-align: center;
      }

      .link {
        margin-top: 10px;
        font-size: 16px;
        top: 70%;
        text-align: center;
      }

      .over {
        text-transform: uppercase;
      }

      .tips {
        margin-top: 25px;
        font-size: 16px;
        text-align: center;
        padding: 0 5px;
      }

      .usersInform {
        text-align: center;
        position: relative;
        top: 100px;
      }

      .show-on-fail-ls {
        text-align: center;
        margin-top: 2em;
      }

      .show-on-fail-ls .btc-open-in-new-tab {
        margin-top: 2em;
      }
      .show-on-fail-ls .btc-open-in-new-tab > A {
        color: #fff;
        text-decoration: none;
      }

      .show-on-fail-ls SPAN {
        display: block;
      }

      .starter-modal {
        position: fixed;
        z-index: 1;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: auto;
        background-color: #fff;
        color: var(--primary);
      }

      .starter-modal__container-content {
        height: 100%;
        padding: 4vh 0 1.4em;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
      }

      .starter-modal__title {
        font-size: 1.6em;
        margin: 0 0.8em 0.7em;
        font-weight: 700;
        text-align: center;
      }

      @media (min-width: 767px) {
        .starter-modal__description-container {
          display: flex;
        }
      }

      .starter-modal__description {
        margin-bottom: 0.5em;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .starter-modal__svg {
        /*width: 18em;*/
        height: 12em;
      }

      .starter-modal__description .text {
        max-width: 22em;
        margin-top: 0;
        padding: 0 0.8em;
        font-size: 1.1em;
        text-align: center;
      }

      .starter-modal__buttons {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .starter-modal__btn-container {
        max-width: 30em;
        width: 100%;
        padding: 0 0.2em;
        display: flex;
      }

      .starter-modal__btn {
        cursor: pointer;
        flex: 1;
        margin: 0.2em;
        padding: 0.7em 1.4em;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 0.1em solid var(--primary);
        border-radius: 0.2em;
        white-space: nowrap;
        letter-spacing: inherit;
        font-family: inherit;
        font-weight: 600;
        font-size: 15px;
        background-color: var(--primary);
        color: #fff;
        transition: 0.15s;
      }

      .starter-modal__btn_skip {
        background-color: transparent;
        color: var(--primary);
      }

      .starter-modal__btn:hover {
        background-color: var(--primary-hover);
        border-color: var(--primary-hover);
      }

      .starter-modal__btn_skip:hover {
        color: #fff;
      }

      .starter-modal__btn svg {
        width: 2em;
        height: 2em;
        margin-right: 0.5em;
      }

      .starter-modal__link-container {
        margin-top: 2vh;
      }

      .starter-modal__link {
        padding: 0;
        background-color: transparent;
        border: none;
        font-size: 15px;
        font-weight: bold;
        text-decoration: underline;
        color: var(--primary);
      }

      @media (max-width: 768px) {
        .starter-modal__container-content {
          padding-top: 3vh;
        }
      }

      @media (max-width: 540px) {
        .starter-modal__container-content {
          font-size: 1em;
        }

        .starter-modal__title {
          font-size: 1.5em;
        }

        .starter-modal__svg {
          width: 16em;
          height: 9em;
        }

        .starter-modal__description .text {
          font-size: 1.05em;
        }

        .starter-modal__btn-container {
          width: 84%;
        }

        .starter-modal__btn {
          padding: 1em 1.6em;
          font-size: 13px;
        }

        .starter-modal__link {
          font-size: 13px;
        }
      }

      @media (max-width: 375px) {
        .starter-modal__title {
          font-size: 1.5em;
        }

        .starter-modal__svg {
          width: 14em;
          height: 8em;
        }

        .starter-modal__description .text {
          font-size: 0.9em;
        }

        .starter-modal__btn-container {
          width: 90%;
        }

        .starter-modal__btn {
          padding: 1em 1.6em;
        }
      }

      @media (max-width: 360px) {
        .starter-modal__title {
          font-size: 1.4em;
        }

        .starter-modal__svg {
          width: 13em;
          height: 7em;
        }
      }

      @media (max-width: 320px) {
        .starter-modal__title {
          font-size: 1.3em;
        }

        .starter-modal__svg {
          width: 11em;
          height: 6em;
        }

        .starter-modal__description .text {
          font-size: 0.8em;
        }

        .starter-modal__btn {
          font-size: 3.6vw;
        }

        .starter-modal__link {
          font-size: 3.9vw;
        }
      }

      @media (max-width: 280px) {
        .starter-modal__title {
          font-size: 1.5em;
          margin-bottom: 0.8em;
        }

        .starter-modal__description .text {
          font-size: 0.95em;
        }

        .starter-modal__description:last-of-type {
          margin-bottom: 1.4em;
        }
      }

      .starter-modal:not(.d-none) ~ #root {
        display: none;
      }
    </style>
  </head>

  <body>
    <!-- Start Modal -->
    <section class="starter-modal d-none" id="starter-modal">
      <div class="starter-modal__container-content">
        <h2 class="starter-modal__title">
          Simple interface to access blockchains
        </h2>

        <div class="starter-modal__description-container">
          <div class="starter-modal__description">
            <svg class="starter-modal__svg" width="396" height="308" viewBox="0 0 396 308" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g filter="url(#filter0_d)">
                <rect x="24" y="22" width="348" height="260" rx="12" fill="#FDFDFD"/>
              </g>
              <path opacity="0.4" d="M48.3089 53.0909L52.288 60.1435V64H54.5785V60.1435L58.5575 53.0909H55.9741L53.4865 57.7891H53.38L50.8924 53.0909H48.3089ZM61.7722 64.1598C64.2544 64.1598 65.7992 62.4606 65.7992 59.9411C65.7992 57.4055 64.2544 55.7116 61.7722 55.7116C59.29 55.7116 57.7452 57.4055 57.7452 59.9411C57.7452 62.4606 59.29 64.1598 61.7722 64.1598ZM61.7828 62.402C60.6376 62.402 60.0517 61.3526 60.0517 59.9251C60.0517 58.4975 60.6376 57.4428 61.7828 57.4428C62.9068 57.4428 63.4927 58.4975 63.4927 59.9251C63.4927 61.3526 62.9068 62.402 61.7828 62.402ZM72.5215 60.5163C72.5268 61.6136 71.7757 62.1889 70.9608 62.1889C70.1032 62.1889 69.5492 61.587 69.5439 60.6229V55.8182H67.2747V61.0277C67.28 62.94 68.3986 64.1065 70.0446 64.1065C71.275 64.1065 72.1593 63.4727 72.5268 62.5138H72.612V64H74.7907V55.8182H72.5215V60.5163ZM76.6057 64H78.8749V59.3711C78.8749 58.3643 79.61 57.6719 80.6114 57.6719C80.9257 57.6719 81.3572 57.7251 81.5702 57.7944V55.7809C81.3678 55.733 81.0855 55.701 80.8564 55.701C79.9403 55.701 79.1892 56.2337 78.8909 57.2457H78.8057V55.8182H76.6057V64ZM90.567 55.8182H89.0276V53.858H86.7584V55.8182H85.6398V57.5227H86.7584V61.7841C86.7478 63.3874 87.8398 64.1811 89.4857 64.1119C90.0716 64.0906 90.4871 63.9734 90.7162 63.8988L90.3593 62.2102C90.2474 62.2315 90.0077 62.2848 89.7947 62.2848C89.3419 62.2848 89.0276 62.1143 89.0276 61.4858V57.5227H90.567V55.8182ZM95.654 64.1598C98.1363 64.1598 99.681 62.4606 99.681 59.9411C99.681 57.4055 98.1363 55.7116 95.654 55.7116C93.1718 55.7116 91.627 57.4055 91.627 59.9411C91.627 62.4606 93.1718 64.1598 95.654 64.1598ZM95.6647 62.402C94.5194 62.402 93.9335 61.3526 93.9335 59.9251C93.9335 58.4975 94.5194 57.4428 95.6647 57.4428C96.7886 57.4428 97.3746 58.4975 97.3746 59.9251C97.3746 61.3526 96.7886 62.402 95.6647 62.402ZM105.508 55.8182H103.969V53.858H101.7V55.8182H100.581V57.5227H101.7V61.7841C101.689 63.3874 102.781 64.1811 104.427 64.1119C105.013 64.0906 105.429 63.9734 105.658 63.8988L105.301 62.2102C105.189 62.2315 104.949 62.2848 104.736 62.2848C104.283 62.2848 103.969 62.1143 103.969 61.4858V57.5227H105.508V55.8182ZM109.32 64.1545C110.529 64.1545 111.312 63.6271 111.711 62.8654H111.775V64H113.927V58.4815C113.927 56.532 112.276 55.7116 110.454 55.7116C108.494 55.7116 107.205 56.6491 106.891 58.1406L108.989 58.3111C109.144 57.7678 109.629 57.3683 110.444 57.3683C111.216 57.3683 111.658 57.7571 111.658 58.4283V58.4602C111.658 58.9876 111.099 59.0568 109.677 59.1953C108.057 59.3445 106.603 59.8878 106.603 61.7148C106.603 63.3342 107.759 64.1545 109.32 64.1545ZM109.97 62.5884C109.272 62.5884 108.771 62.2635 108.771 61.6403C108.771 61.0011 109.298 60.6868 110.097 60.5749C110.593 60.5057 111.402 60.3885 111.674 60.2074V61.0756C111.674 61.9332 110.966 62.5884 109.97 62.5884ZM117.957 53.0909H115.688V64H117.957V53.0909ZM123.289 64H125.526V62.6896H125.627C125.942 63.3714 126.629 64.1332 127.95 64.1332C129.814 64.1332 131.268 62.6577 131.268 59.9197C131.268 57.1072 129.75 55.7116 127.955 55.7116C126.586 55.7116 125.931 56.5266 125.627 57.1925H125.558V53.0909H123.289V64ZM125.51 59.9091C125.51 58.4496 126.128 57.5174 127.231 57.5174C128.355 57.5174 128.951 58.4922 128.951 59.9091C128.951 61.3366 128.344 62.3274 127.231 62.3274C126.139 62.3274 125.51 61.3686 125.51 59.9091ZM135.116 64.1545C136.325 64.1545 137.108 63.6271 137.507 62.8654H137.571V64H139.723V58.4815C139.723 56.532 138.072 55.7116 136.25 55.7116C134.29 55.7116 133.001 56.6491 132.687 58.1406L134.785 58.3111C134.94 57.7678 135.425 57.3683 136.24 57.3683C137.012 57.3683 137.454 57.7571 137.454 58.4283V58.4602C137.454 58.9876 136.895 59.0568 135.472 59.1953C133.853 59.3445 132.399 59.8878 132.399 61.7148C132.399 63.3342 133.555 64.1545 135.116 64.1545ZM135.765 62.5884C135.068 62.5884 134.567 62.2635 134.567 61.6403C134.567 61.0011 135.094 60.6868 135.893 60.5749C136.389 60.5057 137.198 60.3885 137.47 60.2074V61.0756C137.47 61.9332 136.762 62.5884 135.765 62.5884ZM143.753 53.0909H141.484V64H143.753V53.0909ZM147.904 64.1545C149.113 64.1545 149.896 63.6271 150.295 62.8654H150.359V64H152.511V58.4815C152.511 56.532 150.86 55.7116 149.038 55.7116C147.078 55.7116 145.789 56.6491 145.475 58.1406L147.573 58.3111C147.728 57.7678 148.213 57.3683 149.028 57.3683C149.8 57.3683 150.242 57.7571 150.242 58.4283V58.4602C150.242 58.9876 149.683 59.0568 148.261 59.1953C146.641 59.3445 145.187 59.8878 145.187 61.7148C145.187 63.3342 146.343 64.1545 147.904 64.1545ZM148.554 62.5884C147.856 62.5884 147.355 62.2635 147.355 61.6403C147.355 61.0011 147.882 60.6868 148.681 60.5749C149.177 60.5057 149.986 60.3885 150.258 60.2074V61.0756C150.258 61.9332 149.55 62.5884 148.554 62.5884ZM156.541 59.2699C156.546 58.2152 157.175 57.5973 158.091 57.5973C159.002 57.5973 159.551 58.1939 159.545 59.1953V64H161.814V58.7905C161.814 56.8835 160.696 55.7116 158.991 55.7116C157.777 55.7116 156.898 56.3082 156.53 57.2617H156.434V55.8182H154.272V64H156.541V59.2699ZM167.3 64.1598C169.478 64.1598 170.847 62.8814 170.954 61.0011H168.812C168.679 61.8746 168.104 62.3647 167.326 62.3647C166.266 62.3647 165.579 61.4751 165.579 59.9091C165.579 58.3643 166.271 57.4801 167.326 57.4801C168.157 57.4801 168.69 58.0288 168.812 58.8438H170.954C170.858 56.9528 169.425 55.7116 167.289 55.7116C164.807 55.7116 163.273 57.4322 163.273 59.9411C163.273 62.4286 164.78 64.1598 167.3 64.1598ZM176.135 64.1598C178.159 64.1598 179.523 63.1744 179.843 61.6562L177.744 61.5178C177.515 62.141 176.929 62.4659 176.172 62.4659C175.038 62.4659 174.319 61.7148 174.319 60.495V60.4897H179.891V59.8665C179.891 57.0859 178.207 55.7116 176.045 55.7116C173.637 55.7116 172.076 57.4215 172.076 59.9464C172.076 62.5405 173.616 64.1598 176.135 64.1598ZM174.319 59.0835C174.367 58.1513 175.075 57.4055 176.082 57.4055C177.067 57.4055 177.749 58.1087 177.755 59.0835H174.319Z" fill="#103A49"/>
                <rect opacity="0.1" x="266" y="48" width="82" height="24" rx="4" fill="#103A49"/>
                <rect x="307" y="50" width="39" height="20" rx="2" fill="#FDFDFD"/>
              <path d="M320.149 55.2727V60.7827C320.149 61.7798 319.45 62.5 318.376 62.5C317.307 62.5 316.604 61.7798 316.604 60.7827V55.2727H314.759V60.9403C314.759 62.8494 316.199 64.1236 318.376 64.1236C320.545 64.1236 321.994 62.8494 321.994 60.9403V55.2727H320.149ZM328.247 57.7827H330.015C329.99 56.2273 328.711 55.1534 326.768 55.1534C324.855 55.1534 323.453 56.2102 323.461 57.7955C323.457 59.0824 324.365 59.8196 325.839 60.1733L326.789 60.4119C327.74 60.642 328.268 60.9148 328.272 61.5028C328.268 62.142 327.663 62.5767 326.725 62.5767C325.767 62.5767 325.076 62.1335 325.017 61.2599H323.231C323.278 63.1477 324.629 64.1236 326.747 64.1236C328.877 64.1236 330.13 63.1051 330.135 61.5071C330.13 60.054 329.035 59.2827 327.518 58.9418L326.734 58.7543C325.975 58.5795 325.341 58.2983 325.353 57.6719C325.353 57.1094 325.852 56.696 326.755 56.696C327.637 56.696 328.179 57.0966 328.247 57.7827ZM334.469 64C337.129 64 338.739 62.3551 338.739 59.6278C338.739 56.9091 337.129 55.2727 334.495 55.2727H331.376V64H334.469ZM333.221 62.419V56.8537H334.397C336.033 56.8537 336.898 57.6889 336.898 59.6278C336.898 61.5753 336.033 62.419 334.393 62.419H333.221Z" fill="#103A49"/>
              <path d="M274.759 64H278.487C280.447 64 281.491 62.9773 281.491 61.5881C281.491 60.2969 280.567 59.517 279.574 59.4702V59.3849C280.482 59.1804 281.151 58.5369 281.151 57.5099C281.151 56.2017 280.179 55.2727 278.253 55.2727H274.759V64ZM276.604 62.4915V60.1733H278.151C279.037 60.1733 279.587 60.6847 279.587 61.4048C279.587 62.0611 279.139 62.4915 278.108 62.4915H276.604ZM276.604 58.9247V56.7642H278.006C278.824 56.7642 279.288 57.1861 279.288 57.8168C279.288 58.5071 278.726 58.9247 277.972 58.9247H276.604ZM282.36 56.794H285.032V64H286.855V56.794H289.527V55.2727H282.36V56.794ZM298.021 58.3281C297.778 56.3125 296.253 55.1534 294.233 55.1534C291.928 55.1534 290.168 56.7812 290.168 59.6364C290.168 62.483 291.898 64.1193 294.233 64.1193C296.47 64.1193 297.821 62.6321 298.021 61.0256L296.155 61.017C295.98 61.9503 295.247 62.4872 294.263 62.4872C292.938 62.4872 292.038 61.5028 292.038 59.6364C292.038 57.821 292.925 56.7855 294.276 56.7855C295.286 56.7855 296.014 57.3693 296.155 58.3281H298.021Z" fill="#103A49"/>
                <rect x="48" y="187" width="300" height="64" rx="6" fill="white"/>
                <rect x="48.5" y="187.5" width="299" height="63" rx="5.5" stroke="#103A49" fill="#0000" stroke-opacity="0.1"/>
              <path d="M70.8661 207.228H73.0767C73.0447 205.284 71.4467 203.942 69.0178 203.942C66.6261 203.942 64.8736 205.263 64.8842 207.244C64.8789 208.853 66.0135 209.775 67.8565 210.217L69.0444 210.515C70.2322 210.803 70.8928 211.143 70.8981 211.879C70.8928 212.678 70.1364 213.221 68.9645 213.221C67.766 213.221 66.9031 212.667 66.8285 211.575H64.5966C64.6552 213.935 66.3438 215.154 68.9911 215.154C71.6545 215.154 73.2205 213.881 73.2259 211.884C73.2205 210.067 71.8516 209.103 69.9553 208.677L68.9751 208.443C68.027 208.224 67.2333 207.873 67.2493 207.09C67.2493 206.387 67.8725 205.87 69.0018 205.87C70.1044 205.87 70.7809 206.371 70.8661 207.228ZM78.4633 215.16C80.4875 215.16 81.8511 214.174 82.1707 212.656L80.072 212.518C79.843 213.141 79.257 213.466 78.5006 213.466C77.366 213.466 76.6469 212.715 76.6469 211.495V211.49H82.2187V210.866C82.2187 208.086 80.5354 206.712 78.3728 206.712C75.9651 206.712 74.4044 208.422 74.4044 210.946C74.4044 213.54 75.9438 215.16 78.4633 215.16ZM76.6469 210.083C76.6949 209.151 77.4033 208.406 78.4101 208.406C79.3955 208.406 80.0773 209.109 80.0827 210.083H76.6469ZM85.9687 210.27C85.974 209.215 86.6025 208.597 87.5187 208.597C88.4296 208.597 88.9782 209.194 88.9729 210.195V215H91.2421V209.79C91.2421 207.884 90.1235 206.712 88.4189 206.712C87.2045 206.712 86.3256 207.308 85.958 208.262H85.8621V206.818H83.6995V215H85.9687V210.27ZM97.3825 206.818H95.843V204.858H93.5739V206.818H92.4553V208.523H93.5739V212.784C93.5632 214.387 94.6552 215.181 96.3011 215.112C96.8871 215.091 97.3026 214.973 97.5316 214.899L97.1747 213.21C97.0629 213.232 96.8232 213.285 96.6101 213.285C96.1573 213.285 95.843 213.114 95.843 212.486V208.523H97.3825V206.818Z" fill="#103A49"/>
                <rect opacity="0.2" x="64" y="227" width="179" height="8" rx="4" fill="#103A49"/>
                <rect opacity="0.2" x="277" y="227" width="55" height="8" rx="4" fill="#103A49"/>
                <rect opacity="0.2" x="243" y="206" width="89" height="8" rx="4" fill="#EE5B51"/>
                <rect opacity="0.1" x="106" y="203" width="65" height="14" rx="7" fill="#07CB1B"/>
              <path d="M117.639 209.219C117.477 207.875 116.46 207.102 115.114 207.102C113.577 207.102 112.403 208.188 112.403 210.091C112.403 211.989 113.557 213.08 115.114 213.08C116.605 213.08 117.506 212.088 117.639 211.017L116.395 211.011C116.278 211.634 115.79 211.991 115.134 211.991C114.25 211.991 113.651 211.335 113.651 210.091C113.651 208.881 114.241 208.19 115.142 208.19C115.815 208.19 116.301 208.58 116.395 209.219H117.639ZM124.348 210.091C124.348 208.188 123.166 207.102 121.623 207.102C120.072 207.102 118.899 208.188 118.899 210.091C118.899 211.986 120.072 213.08 121.623 213.08C123.166 213.08 124.348 211.994 124.348 210.091ZM123.101 210.091C123.101 211.324 122.516 211.991 121.623 211.991C120.729 211.991 120.146 211.324 120.146 210.091C120.146 208.858 120.729 208.19 121.623 208.19C122.516 208.19 123.101 208.858 123.101 210.091ZM130.606 207.182H129.381V210.841H129.33L126.819 207.182H125.739V213H126.969V209.338H127.012L129.543 213H130.606V207.182ZM132.102 213H133.332V210.597H135.699V209.582H133.332V208.196H135.954V207.182H132.102V213ZM138.492 207.182H137.262V213H138.492V207.182ZM139.984 213H141.214V210.938H142.112L143.214 213H144.572L143.336 210.739C143.998 210.455 144.364 209.878 144.364 209.082C144.364 207.926 143.6 207.182 142.279 207.182H139.984V213ZM141.214 209.949V208.188H142.043C142.754 208.188 143.097 208.503 143.097 209.082C143.097 209.659 142.754 209.949 142.049 209.949H141.214ZM145.714 207.182V213H146.907V209.199H146.955L148.461 212.972H149.273L150.779 209.213H150.827V213H152.021V207.182H150.504L148.901 211.091H148.833L147.231 207.182H145.714ZM153.514 213H157.446V211.986H154.744V210.597H157.233V209.582H154.744V208.196H157.435V207.182H153.514V213ZM160.955 213C162.728 213 163.802 211.903 163.802 210.085C163.802 208.273 162.728 207.182 160.972 207.182H158.893V213H160.955ZM160.123 211.946V208.236H160.907C161.998 208.236 162.574 208.793 162.574 210.085C162.574 211.384 161.998 211.946 160.904 211.946H160.123Z" fill="#07CB1B"/>
              <path d="M52.1484 161L53.3359 157.352H59.1094L60.2969 161H63.9219L58.4063 145H54.0469L48.5234 161H52.1484ZM54.1953 154.711L56.1641 148.656H56.2891L58.2578 154.711H54.1953ZM70.6484 161.234C73.8438 161.234 75.8516 159.359 76.0078 156.602H72.8672C72.6719 157.883 71.8281 158.602 70.6875 158.602C69.1328 158.602 68.125 157.297 68.125 155C68.125 152.734 69.1406 151.437 70.6875 151.437C71.9063 151.437 72.6875 152.242 72.8672 153.438H76.0078C75.8672 150.664 73.7656 148.844 70.6328 148.844C66.9922 148.844 64.7422 151.367 64.7422 155.047C64.7422 158.695 66.9531 161.234 70.6484 161.234ZM84.5215 149H82.2637V146.125H78.9355V149H77.2949V151.5H78.9355V157.75C78.9199 160.102 80.5215 161.266 82.9355 161.164C83.7949 161.133 84.4043 160.961 84.7402 160.852L84.2168 158.375C84.0527 158.406 83.7012 158.484 83.3887 158.484C82.7246 158.484 82.2637 158.234 82.2637 157.312V151.5H84.5215V149ZM86.6895 161H90.0176V149H86.6895V161ZM88.3613 147.453C89.3535 147.453 90.166 146.695 90.166 145.766C90.166 144.844 89.3535 144.086 88.3613 144.086C87.377 144.086 86.5645 144.844 86.5645 145.766C86.5645 146.695 87.377 147.453 88.3613 147.453ZM103.871 149H100.348L97.8633 157.586H97.7383L95.2461 149H91.7305L95.9258 161H99.6758L103.871 149ZM105.574 161H108.902V149H105.574V161ZM107.246 147.453C108.238 147.453 109.051 146.695 109.051 145.766C109.051 144.844 108.238 144.086 107.246 144.086C106.262 144.086 105.449 144.844 105.449 145.766C105.449 146.695 106.262 147.453 107.246 147.453ZM117.951 149H115.693V146.125H112.365V149H110.725V151.5H112.365V157.75C112.35 160.102 113.951 161.266 116.365 161.164C117.225 161.133 117.834 160.961 118.17 160.852L117.646 158.375C117.482 158.406 117.131 158.484 116.818 158.484C116.154 158.484 115.693 158.234 115.693 157.312V151.5H117.951V149ZM122.174 165.5C124.65 165.5 125.963 164.234 126.643 162.297L131.307 149.016L127.783 149L125.275 157.812H125.15L122.666 149H119.166L123.471 161.344L123.275 161.852C122.838 162.977 122.002 163.031 120.83 162.672L120.08 165.156C120.557 165.359 121.33 165.5 122.174 165.5Z" fill="#103A49"/>
              <path d="M59.7997 109.358C65.6804 109.358 69.8864 106.124 69.8736 101.649C69.8864 98.3892 67.8153 96.0625 63.9673 95.5767V95.3722C66.8949 94.848 68.9148 92.777 68.902 89.8366C68.9148 85.7074 65.2969 82.4602 59.8764 82.4602C54.5071 82.4602 50.4673 85.6051 50.3906 90.1307H55.696C55.7599 88.1364 57.5881 86.8452 59.8509 86.8452C62.0881 86.8452 63.5838 88.2003 63.571 90.169C63.5838 92.2273 61.8324 93.6207 59.3139 93.6207H56.8722V97.6861H59.3139C62.2798 97.6861 64.1335 99.169 64.1207 101.278C64.1335 103.362 62.3438 104.794 59.8125 104.794C57.3707 104.794 55.5426 103.516 55.4403 101.598H49.8665C49.956 106.175 54.0469 109.358 59.7997 109.358ZM74.8881 109H80.6026L91.4691 87.4077V82.8182H73.0984V87.3438H85.7418V87.5227L74.8881 109ZM106.653 82.8182H101.45L94.9688 86.9219V91.831L100.964 88.0724H101.118V109H106.653V82.8182ZM122.439 109.358C128.268 109.358 132.231 105.561 132.218 100.268C132.231 95.2571 128.728 91.652 124.011 91.652C121.71 91.652 119.728 92.6108 118.808 93.902H118.654L119.332 87.3438H130.774V82.8182H114.768L113.528 96.625L118.45 97.5071C119.255 96.4205 120.815 95.7429 122.362 95.7429C124.995 95.7557 126.887 97.6605 126.887 100.409C126.887 103.132 125.034 105.011 122.439 105.011C120.24 105.011 118.463 103.631 118.335 101.598H112.966C113.068 106.124 117.018 109.358 122.439 109.358ZM138.505 109.332C140.141 109.332 141.56 107.964 141.573 106.264C141.56 104.589 140.141 103.222 138.505 103.222C136.817 103.222 135.424 104.589 135.437 106.264C135.424 107.964 136.817 109.332 138.505 109.332ZM154.114 82.8182H148.911L142.43 86.9219V91.831L148.425 88.0724H148.579V109H154.114V82.8182ZM169.81 82.4602C163.955 82.4347 160.005 86.2699 160.03 91.5369C160.043 96.4205 163.431 99.9616 168.071 99.9616C170.948 99.9616 173.505 98.5682 174.668 96.267H174.847C174.834 101.457 173.032 104.615 169.618 104.615C167.611 104.615 166.167 103.516 165.745 101.611H160.286C160.797 106.021 164.377 109.358 169.618 109.358C176.1 109.358 180.28 104.116 180.267 95.2315C180.255 85.7457 175.192 82.4858 169.81 82.4602ZM169.848 86.8068C172.392 86.8068 174.272 88.8778 174.297 91.3707C174.31 93.8764 172.328 95.9474 169.797 95.9474C167.24 95.9474 165.412 93.9531 165.4 91.3835C165.374 88.8267 167.279 86.8068 169.848 86.8068Z" fill="#103A49"/>
              <defs>
                <filter id="filter0_d" x="0" y="0" width="396" height="308" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                  <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>
                  <feOffset dy="2"/>
                  <feGaussianBlur stdDeviation="12"/>
                  <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.08 0"/>
                  <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                  <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>
                </filter>
              </defs>
            </svg>
            <p class="text">
              Store, send, receive cryptocurrencies<br>
              (Bitcoin, Ethereum, tokens...)<br>
              without installation and registration
            </p>
          </div>

          <div class="starter-modal__description">
            <svg class="starter-modal__svg" width="396" height="269" viewBox="0 0 396 269" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g filter="url(#filter0_d)">
                <path d="M24 34C24 27.3726 29.3726 22 36 22H360C366.627 22 372 27.3726 372 34V231C372 237.627 366.627 243 360 243H36C29.3726 243 24 237.627 24 231V34Z" fill="#FDFDFD"/>
              </g>
                <rect x="48" y="57" width="300" height="56" rx="2" fill="white"/>
                <rect x="48.5" y="57.5" width="299" height="55" rx="1.5" stroke="black" fill="#0000" stroke-opacity="0.1"/>
              <path d="M276.2 92H285.717V89.7912H278.835V85.821H285.17V83.6122H278.835V79.6634H285.661V77.4545H276.2V92ZM287.71 79.6634H292.205V92H294.819V79.6634H299.315V77.4545H287.71V79.6634ZM301.552 92H304.187V85.821H310.927V92H313.569V77.4545H310.927V83.6122H304.187V77.4545H301.552V92Z" fill="black"/>
              <path d="M332 84L328 88L324 84" stroke="black" stroke-width="1.8" stroke-linecap="round"/>
              <path opacity="0.2" d="M66 86C66 81.5817 69.5817 78 74 78H103C107.418 78 111 81.5817 111 86V86C111 90.4183 107.418 94 103 94H74C69.5817 94 66 90.4183 66 86V86Z" fill="#103A49"/>
                <rect x="49" y="143" width="298" height="54" rx="1" fill="white" stroke="#6144E5" stroke-width="2"/>
                <rect x="254" y="186" width="86" height="25" fill="white"/>
              <path d="M274.849 177H280.737C284.067 177 285.701 175.303 285.701 173.037C285.701 170.835 284.138 169.543 282.59 169.464V169.322C284.011 168.989 285.133 167.994 285.133 166.226C285.133 164.06 283.57 162.455 280.417 162.455H274.849V177ZM277.484 174.798V170.537H280.388C282.015 170.537 283.023 171.531 283.023 172.831C283.023 173.989 282.228 174.798 280.317 174.798H277.484ZM277.484 168.641V164.628H280.147C281.695 164.628 282.498 165.445 282.498 166.567C282.498 167.845 281.461 168.641 280.09 168.641H277.484ZM287.354 164.663H291.85V177H294.463V164.663H298.959V162.455H287.354V164.663ZM313.022 167.362C312.574 164.131 310.088 162.256 306.864 162.256C303.064 162.256 300.202 165.026 300.202 169.727C300.202 174.422 303.029 177.199 306.864 177.199C310.323 177.199 312.617 174.962 313.022 172.185L310.365 172.17C310.032 173.875 308.64 174.834 306.9 174.834C304.542 174.834 302.851 173.065 302.851 169.727C302.851 166.446 304.527 164.621 306.907 164.621C308.675 164.621 310.06 165.622 310.365 167.362H313.022Z" fill="black"/>
              <path d="M332 169L328 173L324 169" stroke="black" stroke-width="1.8" stroke-linecap="round"/>
              <path opacity="0.2" d="M260 197.5C260 195.015 262.015 193 264.5 193H327.5C329.985 193 332 195.015 332 197.5V197.5C332 199.985 329.985 202 327.5 202H264.5C262.015 202 260 199.985 260 197.5V197.5Z" fill="#103A49"/>
              <path opacity="0.2" d="M67 171C67 166.582 70.5817 163 75 163H104C108.418 163 112 166.582 112 171V171C112 175.418 108.418 179 104 179H75C70.5817 179 67 175.418 67 171V171Z" fill="#103A49"/>
                <rect x="58" y="129" width="71" height="25" fill="white"/>
              <path d="M64.3089 136.091L68.288 143.143V147H70.5785V143.143L74.5575 136.091H71.9741L69.4865 140.789H69.38L66.8924 136.091H64.3089ZM77.7722 147.16C80.2544 147.16 81.7992 145.461 81.7992 142.941C81.7992 140.406 80.2544 138.712 77.7722 138.712C75.29 138.712 73.7452 140.406 73.7452 142.941C73.7452 145.461 75.29 147.16 77.7722 147.16ZM77.7828 145.402C76.6376 145.402 76.0517 144.353 76.0517 142.925C76.0517 141.498 76.6376 140.443 77.7828 140.443C78.9068 140.443 79.4927 141.498 79.4927 142.925C79.4927 144.353 78.9068 145.402 77.7828 145.402ZM88.5215 143.516C88.5268 144.614 87.7757 145.189 86.9608 145.189C86.1032 145.189 85.5492 144.587 85.5439 143.623V138.818H83.2747V144.028C83.28 145.94 84.3986 147.107 86.0446 147.107C87.275 147.107 88.1593 146.473 88.5268 145.514H88.612V147H90.7907V138.818H88.5215V143.516ZM99.7635 150.239C102.102 150.239 103.764 149.173 103.764 147.08V138.818H101.511V140.192H101.425C101.122 139.527 100.456 138.712 99.087 138.712C97.2919 138.712 95.7738 140.107 95.7738 142.893C95.7738 145.615 97.2493 146.883 99.0923 146.883C100.397 146.883 101.127 146.228 101.425 145.551H101.521V147.048C101.521 148.172 100.802 148.609 99.8168 148.609C98.8153 148.609 98.3093 148.172 98.1229 147.676L96.0241 147.959C96.2958 149.248 97.5582 150.239 99.7635 150.239ZM99.8114 145.178C98.6982 145.178 98.0909 144.294 98.0909 142.882C98.0909 141.492 98.6875 140.517 99.8114 140.517C100.914 140.517 101.532 141.45 101.532 142.882C101.532 144.326 100.903 145.178 99.8114 145.178ZM109.298 147.16C111.322 147.16 112.686 146.174 113.006 144.656L110.907 144.518C110.678 145.141 110.092 145.466 109.336 145.466C108.201 145.466 107.482 144.715 107.482 143.495V143.49H113.054V142.866C113.054 140.086 111.37 138.712 109.208 138.712C106.8 138.712 105.239 140.422 105.239 142.946C105.239 145.54 106.779 147.16 109.298 147.16ZM107.482 142.083C107.53 141.151 108.238 140.406 109.245 140.406C110.23 140.406 110.912 141.109 110.918 142.083H107.482ZM118.886 138.818H117.347V136.858H115.078V138.818H113.959V140.523H115.078V144.784C115.067 146.387 116.159 147.181 117.805 147.112C118.391 147.091 118.806 146.973 119.036 146.899L118.679 145.21C118.567 145.232 118.327 145.285 118.114 145.285C117.661 145.285 117.347 145.114 117.347 144.486V140.523H118.886V138.818Z" fill="black" fill-opacity="0.8"/>
                <rect x="58" y="51" width="50" height="25" fill="white"/>
              <path d="M64.3089 53.0909L68.288 60.1435V64H70.5785V60.1435L74.5575 53.0909H71.9741L69.4865 57.7891H69.38L66.8924 53.0909H64.3089ZM77.7722 64.1598C80.2544 64.1598 81.7992 62.4606 81.7992 59.9411C81.7992 57.4055 80.2544 55.7116 77.7722 55.7116C75.29 55.7116 73.7452 57.4055 73.7452 59.9411C73.7452 62.4606 75.29 64.1598 77.7722 64.1598ZM77.7828 62.402C76.6376 62.402 76.0517 61.3526 76.0517 59.9251C76.0517 58.4975 76.6376 57.4428 77.7828 57.4428C78.9068 57.4428 79.4927 58.4975 79.4927 59.9251C79.4927 61.3526 78.9068 62.402 77.7828 62.402ZM88.5215 60.5163C88.5268 61.6136 87.7757 62.1889 86.9608 62.1889C86.1032 62.1889 85.5492 61.587 85.5439 60.6229V55.8182H83.2747V61.0277C83.28 62.94 84.3986 64.1065 86.0446 64.1065C87.275 64.1065 88.1593 63.4727 88.5268 62.5138H88.612V64H90.7907V55.8182H88.5215V60.5163ZM96.0774 67.0682H98.3466V62.6896H98.4158C98.7301 63.3714 99.4173 64.1332 100.738 64.1332C102.603 64.1332 104.057 62.6577 104.057 59.9197C104.057 57.1072 102.539 55.7116 100.744 55.7116C99.3746 55.7116 98.7195 56.5266 98.4158 57.1925H98.3146V55.8182H96.0774V67.0682ZM98.2987 59.9091C98.2987 58.4496 98.9165 57.5174 100.019 57.5174C101.143 57.5174 101.74 58.4922 101.74 59.9091C101.74 61.3366 101.132 62.3274 100.019 62.3274C98.9272 62.3274 98.2987 61.3686 98.2987 59.9091ZM107.903 64.1545C109.112 64.1545 109.895 63.6271 110.294 62.8654H110.358V64H112.51V58.4815C112.51 56.532 110.859 55.7116 109.037 55.7116C107.077 55.7116 105.788 56.6491 105.474 58.1406L107.572 58.3111C107.727 57.7678 108.212 57.3683 109.027 57.3683C109.799 57.3683 110.241 57.7571 110.241 58.4283V58.4602C110.241 58.9876 109.682 59.0568 108.26 59.1953C106.64 59.3445 105.186 59.8878 105.186 61.7148C105.186 63.3342 106.342 64.1545 107.903 64.1545ZM108.553 62.5884C107.855 62.5884 107.354 62.2635 107.354 61.6403C107.354 61.0011 107.881 60.6868 108.68 60.5749C109.176 60.5057 109.985 60.3885 110.257 60.2074V61.0756C110.257 61.9332 109.549 62.5884 108.553 62.5884ZM115.379 67.0682C117.067 67.0682 117.962 66.2053 118.426 64.8842L121.606 55.8288L119.203 55.8182L117.493 61.8267H117.408L115.714 55.8182H113.328L116.263 64.2344L116.13 64.5806C115.831 65.3477 115.262 65.3849 114.463 65.1399L113.951 66.8338C114.276 66.9723 114.803 67.0682 115.379 67.0682Z" fill="#103A49"/>
              <defs>
                <filter id="filter0_d" x="0" y="0" width="396" height="269" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                  <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>
                  <feOffset dy="2"/>
                  <feGaussianBlur stdDeviation="12"/>
                  <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.08 0"/>
                  <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                  <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>
                </filter>
              </defs>
            </svg>
            <p class="text">
              Trade on the decentralized P2P exchange<br>
              using atomic swap technology
            </p>
          </div>
        </div>

        <div class="starter-modal__buttons">
          <div class="starter-modal__btn-container">
            <button id="preloaderCreateBtn" class="starter-modal__btn">
              Create Wallet
            </button>
            <button id="preloaderConnectBtn" class="starter-modal__btn">
              <?xml version="1.0" encoding="utf-8"?>
              <svg version="1.1"
                xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 318.6 318.6">
              <style type="text/css">
                .st0{fill:#E2761B;stroke:#E2761B;stroke-linecap:round;stroke-linejoin:round;}
                .st1{fill:#E4761B;stroke:#E4761B;stroke-linecap:round;stroke-linejoin:round;}
                .st2{fill:#D7C1B3;stroke:#D7C1B3;stroke-linecap:round;stroke-linejoin:round;}
                .st3{fill:#233447;stroke:#233447;stroke-linecap:round;stroke-linejoin:round;}
                .st4{fill:#CD6116;stroke:#CD6116;stroke-linecap:round;stroke-linejoin:round;}
                .st5{fill:#E4751F;stroke:#E4751F;stroke-linecap:round;stroke-linejoin:round;}
                .st6{fill:#F6851B;stroke:#F6851B;stroke-linecap:round;stroke-linejoin:round;}
                .st7{fill:#C0AD9E;stroke:#C0AD9E;stroke-linecap:round;stroke-linejoin:round;}
                .st8{fill:#161616;stroke:#161616;stroke-linecap:round;stroke-linejoin:round;}
                .st9{fill:#763D16;stroke:#763D16;stroke-linecap:round;stroke-linejoin:round;}
              </style>
              <polygon class="st0" points="274.1,35.5 174.6,109.4 193,65.8 "/>
              <g>
                <polygon class="st1" points="44.4,35.5 143.1,110.1 125.6,65.8 	"/>
                <polygon class="st1" points="238.3,206.8 211.8,247.4 268.5,263 284.8,207.7 	"/>
                <polygon class="st1" points="33.9,207.7 50.1,263 106.8,247.4 80.3,206.8 	"/>
                <polygon class="st1" points="103.6,138.2 87.8,162.1 144.1,164.6 142.1,104.1 	"/>
                <polygon class="st1" points="214.9,138.2 175.9,103.4 174.6,164.6 230.8,162.1 	"/>
                <polygon class="st1" points="106.8,247.4 140.6,230.9 111.4,208.1 	"/>
                <polygon class="st1" points="177.9,230.9 211.8,247.4 207.1,208.1 	"/>
              </g>
              <g>
                <polygon class="st2" points="211.8,247.4 177.9,230.9 180.6,253 180.3,262.3 	"/>
                <polygon class="st2" points="106.8,247.4 138.3,262.3 138.1,253 140.6,230.9 	"/>
              </g>
              <polygon class="st3" points="138.8,193.5 110.6,185.2 130.5,176.1 "/>
              <polygon class="st3" points="179.7,193.5 188,176.1 208,185.2 "/>
              <g>
                <polygon class="st4" points="106.8,247.4 111.6,206.8 80.3,207.7 	"/>
                <polygon class="st4" points="207,206.8 211.8,247.4 238.3,207.7 	"/>
                <polygon class="st4" points="230.8,162.1 174.6,164.6 179.8,193.5 188.1,176.1 208.1,185.2 	"/>
                <polygon class="st4" points="110.6,185.2 130.6,176.1 138.8,193.5 144.1,164.6 87.8,162.1 	"/>
              </g>
              <g>
                <polygon class="st5" points="87.8,162.1 111.4,208.1 110.6,185.2 	"/>
                <polygon class="st5" points="208.1,185.2 207.1,208.1 230.8,162.1 	"/>
                <polygon class="st5" points="144.1,164.6 138.8,193.5 145.4,227.6 146.9,182.7 	"/>
                <polygon class="st5" points="174.6,164.6 171.9,182.6 173.1,227.6 179.8,193.5 	"/>
              </g>
              <polygon class="st6" points="179.8,193.5 173.1,227.6 177.9,230.9 207.1,208.1 208.1,185.2 "/>
              <polygon class="st6" points="110.6,185.2 111.4,208.1 140.6,230.9 145.4,227.6 138.8,193.5 "/>
              <polygon class="st7" points="180.3,262.3 180.6,253 178.1,250.8 140.4,250.8 138.1,253 138.3,262.3 106.8,247.4 117.8,256.4 
                140.1,271.9 178.4,271.9 200.8,256.4 211.8,247.4 "/>
              <polygon class="st8" points="177.9,230.9 173.1,227.6 145.4,227.6 140.6,230.9 138.1,253 140.4,250.8 178.1,250.8 180.6,253 "/>
              <g>
                <polygon class="st9" points="278.3,114.2 286.8,73.4 274.1,35.5 177.9,106.9 214.9,138.2 267.2,153.5 278.8,140 273.8,136.4 
                  281.8,129.1 275.6,124.3 283.6,118.2 	"/>
                <polygon class="st9" points="31.8,73.4 40.3,114.2 34.9,118.2 42.9,124.3 36.8,129.1 44.8,136.4 39.8,140 51.3,153.5 103.6,138.2 
                  140.6,106.9 44.4,35.5 	"/>
              </g>
              <polygon class="st6" points="267.2,153.5 214.9,138.2 230.8,162.1 207.1,208.1 238.3,207.7 284.8,207.7 "/>
              <polygon class="st6" points="103.6,138.2 51.3,153.5 33.9,207.7 80.3,207.7 111.4,208.1 87.8,162.1 "/>
              <polygon class="st6" points="174.6,164.6 177.9,106.9 193.1,65.8 125.6,65.8 140.6,106.9 144.1,164.6 145.3,182.8 145.4,227.6 
                173.1,227.6 173.3,182.8 "/>
              </svg>
              Connect Wallet
            </button>
          </div>
          <div class="starter-modal__btn-container">
            <button id="preloaderRestoreBtn" class="starter-modal__btn starter-modal__btn_skip">
              Restore from 12-word seed
            </button> 
          </div>
          <div class="starter-modal__link-container">
            <button id="preloaderSkipBtn" class="starter-modal__link">
              Skip
            </button>
          </div>
        </div>
      </div>
    </section>

    <div id="root">
      <!-- Loader before any JS -->
      <div id="wrapper_element" class="overlay">
        <div class="center">
          <div id="loader" class="loader">
            <img id="loaderImg" />
          </div>
          <div id="beforeJSTip" class="tips">Loading...</div>
        </div>
        <div class="mb-4 show-on-fail-ls d-none" id="onFailLocalStorageMessage">
          <span
            >Not every function works In this window, please open new tab. If
            the error will repeat please contact admin
            <br />
            <a href="https://t.me/sashanoxon"> https://t.me/sashanoxon </a>
          </span>
          <button class="btn btn-primary btc-open-in-new-tab">
            <a
              href="https://wallet.wpmix.net"
              id="onFailLocalStorageLink"
              target="_blank"
            >
              Open App in new tab
            </a>
          </button>
        </div>
        <div id="usersInform" class="usersInform"></div>
      </div>
    </div>

    <div id="portal"></div>

    <script type="text/javascript" src="https://unpkg.com/react@16.10.2/umd/react.production.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/react-dom@16.10.2/umd/react-dom.production.min.js"></script>

    // Use OwnBuffer for bn.js package in bitcore-lib
    <script type="text/javascript" id="OwnBuffer">
      var lookup = []
      var revLookup = []
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i]
        revLookup[code.charCodeAt(i)] = i
      }

      // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications
      revLookup['-'.charCodeAt(0)] = 62
      revLookup['_'.charCodeAt(0)] = 63

      function getLens (b64) {
        var len = b64.length

        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4')
        }

        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        var validLen = b64.indexOf('=')
        if (validLen === -1) validLen = len

        var placeHoldersLen = validLen === len
          ? 0
          : 4 - (validLen % 4)

        return [validLen, placeHoldersLen]
      }

      // base64 is 4/3 + up to two characters of the original data
      function byteLength (b64) {
        var lens = getLens(b64)
        var validLen = lens[0]
        var placeHoldersLen = lens[1]
        return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
      }

      function _byteLength (b64, validLen, placeHoldersLen) {
        return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
      }

      function toByteArray (b64) {
        var tmp
        var lens = getLens(b64)
        var validLen = lens[0]
        var placeHoldersLen = lens[1]

        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

        var curByte = 0

        // if there are placeholders, only get up to the last complete 4 chars
        var len = placeHoldersLen > 0
          ? validLen - 4
          : validLen

        var i
        for (i = 0; i < len; i += 4) {
          tmp =
            (revLookup[b64.charCodeAt(i)] << 18) |
            (revLookup[b64.charCodeAt(i + 1)] << 12) |
            (revLookup[b64.charCodeAt(i + 2)] << 6) |
            revLookup[b64.charCodeAt(i + 3)]
          arr[curByte++] = (tmp >> 16) & 0xFF
          arr[curByte++] = (tmp >> 8) & 0xFF
          arr[curByte++] = tmp & 0xFF
        }

        if (placeHoldersLen === 2) {
          tmp =
            (revLookup[b64.charCodeAt(i)] << 2) |
            (revLookup[b64.charCodeAt(i + 1)] >> 4)
          arr[curByte++] = tmp & 0xFF
        }

        if (placeHoldersLen === 1) {
          tmp =
            (revLookup[b64.charCodeAt(i)] << 10) |
            (revLookup[b64.charCodeAt(i + 1)] << 4) |
            (revLookup[b64.charCodeAt(i + 2)] >> 2)
          arr[curByte++] = (tmp >> 8) & 0xFF
          arr[curByte++] = tmp & 0xFF
        }

        return arr
      }

      function tripletToBase64 (num) {
        return lookup[num >> 18 & 0x3F] +
          lookup[num >> 12 & 0x3F] +
          lookup[num >> 6 & 0x3F] +
          lookup[num & 0x3F]
      }

      function encodeChunk (uint8, start, end) {
        var tmp
        var output = []
        for (var i = start; i < end; i += 3) {
          tmp =
            ((uint8[i] << 16) & 0xFF0000) +
            ((uint8[i + 1] << 8) & 0xFF00) +
            (uint8[i + 2] & 0xFF)
          output.push(tripletToBase64(tmp))
        }
        return output.join('')
      }

      function fromByteArray (uint8) {
        var tmp
        var len = uint8.length
        var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
        var parts = []
        var maxChunkLength = 16383 // must be multiple of 3

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
          tmp = uint8[len - 1]
          parts.push(
            lookup[tmp >> 2] +
            lookup[(tmp << 4) & 0x3F] +
            '=='
          )
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1]
          parts.push(
            lookup[tmp >> 10] +
            lookup[(tmp >> 4) & 0x3F] +
            lookup[(tmp << 2) & 0x3F] +
            '='
          )
        }

        return parts.join('')
      }

       function ieee754Read (buffer, offset, isLE, mLen, nBytes) {
          let e, m
          const eLen = (nBytes * 8) - mLen - 1
          const eMax = (1 << eLen) - 1
          const eBias = eMax >> 1
          let nBits = -7
          let i = isLE ? (nBytes - 1) : 0
          const d = isLE ? -1 : 1
          let s = buffer[offset + i]

          i += d

          e = s & ((1 << (-nBits)) - 1)
          s >>= (-nBits)
          nBits += eLen
          while (nBits > 0) {
            e = (e * 256) + buffer[offset + i]
            i += d
            nBits -= 8
          }

          m = e & ((1 << (-nBits)) - 1)
          e >>= (-nBits)
          nBits += mLen
          while (nBits > 0) {
            m = (m * 256) + buffer[offset + i]
            i += d
            nBits -= 8
          }

          if (e === 0) {
            e = 1 - eBias
          } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity)
          } else {
            m = m + Math.pow(2, mLen)
            e = e - eBias
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        function ieee754Write (buffer, value, offset, isLE, mLen, nBytes) {
          let e, m, c
          let eLen = (nBytes * 8) - mLen - 1
          const eMax = (1 << eLen) - 1
          const eBias = eMax >> 1
          const rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
          let i = isLE ? 0 : (nBytes - 1)
          const d = isLE ? 1 : -1
          const s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

          value = Math.abs(value)

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0
            e = eMax
          } else {
            e = Math.floor(Math.log(value) / Math.LN2)
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--
              c *= 2
            }
            if (e + eBias >= 1) {
              value += rt / c
            } else {
              value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
              e++
              c /= 2
            }

            if (e + eBias >= eMax) {
              m = 0
              e = eMax
            } else if (e + eBias >= 1) {
              m = ((value * c) - 1) * Math.pow(2, mLen)
              e = e + eBias
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
              e = 0
            }
          }

          while (mLen >= 8) {
            buffer[offset + i] = m & 0xff
            i += d
            m /= 256
            mLen -= 8
          }

          e = (e << mLen) | m
          eLen += mLen
          while (eLen > 0) {
            buffer[offset + i] = e & 0xff
            i += d
            e /= 256
            eLen -= 8
          }

          buffer[offset + i - d] |= s * 128
        }

      const customInspectSymbol =
        (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
          ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
          : null

      const INSPECT_MAX_BYTES = 50
      const K_MAX_LENGTH = 0x7fffffff

      /**
       * If `OwnBuffer.TYPED_ARRAY_SUPPORT`:
       *   === true    Use Uint8Array implementation (fastest)
       *   === false   Print warning and recommend using `buffer` v4.x which has an Object
       *               implementation (most compatible, even IE6)
       *
       * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
       * Opera 11.6+, iOS 4.2+.
       *
       * We report that the browser does not support typed arrays if the are not subclassable
       * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
       * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
       * for __proto__ and has a buggy typed array implementation.
       */
      OwnBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

      if (!OwnBuffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
          typeof console.error === 'function') {
        console.error(
          'This browser lacks typed array (Uint8Array) support which is required by ' +
          '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
        )
      }

      function typedArraySupport () {
        // Can typed array instances can be augmented?
        try {
          const arr = new Uint8Array(1)
          const proto = { foo: function () { return 42 } }
          Object.setPrototypeOf(proto, Uint8Array.prototype)
          Object.setPrototypeOf(arr, proto)
          return arr.foo() === 42
        } catch (e) {
          return false
        }
      }

      Object.defineProperty(OwnBuffer.prototype, 'parent', {
        enumerable: true,
        get: function () {
          if (!OwnBuffer.isBuffer(this)) return undefined
          return this.buffer
        }
      })

      Object.defineProperty(OwnBuffer.prototype, 'offset', {
        enumerable: true,
        get: function () {
          if (!OwnBuffer.isBuffer(this)) return undefined
          return this.byteOffset
        }
      })

      function createBuffer (length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"')
        }
        // Return an augmented `Uint8Array` instance
        const buf = new Uint8Array(length)
        Object.setPrototypeOf(buf, OwnBuffer.prototype)
        return buf
      }

      /**
       * The Buffer constructor returns instances of `Uint8Array` that have their
       * prototype changed to `OwnBuffer.prototype`. Furthermore, `Buffer` is a subclass of
       * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
       * and the `Uint8Array` methods. Square bracket notation works as expected -- it
       * returns a single octet.
       *
       * The `Uint8Array` prototype remains unmodified.
       */

      function OwnBuffer (arg, encodingOrOffset, length) {
        // Common case.
        if (typeof arg === 'number') {
          if (typeof encodingOrOffset === 'string') {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            )
          }
          return allocUnsafe(arg)
        }
        return from(arg, encodingOrOffset, length)
      }

      OwnBuffer.poolSize = 8192 // not used by this implementation

      function from (value, encodingOrOffset, length) {
        if (typeof value === 'string') {
          return fromString(value, encodingOrOffset)
        }

        if (ArrayOwnBuffer.isView(value)) {
          return fromArrayView(value)
        }

        if (value == null) {
          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
            'or Array-like Object. Received type ' + (typeof value)
          )
        }

        if (isInstance(value, ArrayBuffer) ||
            (value && isInstance(value.buffer, ArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length)
        }

        if (typeof SharedArrayBuffer !== 'undefined' &&
            (isInstance(value, SharedArrayBuffer) ||
            (value && isInstance(value.buffer, SharedArrayBuffer)))) {
          return fromArrayBuffer(value, encodingOrOffset, length)
        }

        if (typeof value === 'number') {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          )
        }

        const valueOf = value.valueOf && value.valueOf()
        if (valueOf != null && valueOf !== value) {
          return OwnBuffer.from(valueOf, encodingOrOffset, length)
        }

        const b = fromObject(value)
        if (b) return b

        if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
            typeof value[Symbol.toPrimitive] === 'function') {
          return OwnBuffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
        }

        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
          'or Array-like Object. Received type ' + (typeof value)
        )
      }

      /**
       * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
       * if value is a number.
       * OwnBuffer.from(str[, encoding])
       * OwnBuffer.from(array)
       * OwnBuffer.from(buffer)
       * OwnBuffer.from(arrayBuffer[, byteOffset[, length]])
       **/
      OwnBuffer.from = function (value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length)
      }

      // Note: Change prototype *after* OwnBuffer.from is defined to workaround Chrome bug:
      // https://github.com/feross/buffer/pull/148
      Object.setPrototypeOf(OwnBuffer.prototype, Uint8Array.prototype)
      Object.setPrototypeOf(OwnBuffer, Uint8Array)

      function assertSize (size) {
        if (typeof size !== 'number') {
          throw new TypeError('"size" argument must be of type number')
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"')
        }
      }

      function alloc (size, fill, encoding) {
        assertSize(size)
        if (size <= 0) {
          return createBuffer(size)
        }
        if (fill !== undefined) {
          // Only pay attention to encoding if it's a string. This
          // prevents accidentally sending in a number that would
          // be interpreted as a start offset.
          return typeof encoding === 'string'
            ? createBuffer(size).fill(fill, encoding)
            : createBuffer(size).fill(fill)
        }
        return createBuffer(size)
      }

      /**
       * Creates a new filled Buffer instance.
       * alloc(size[, fill[, encoding]])
       **/
      OwnBuffer.alloc = function (size, fill, encoding) {
        return alloc(size, fill, encoding)
      }

      function allocUnsafe (size) {
        assertSize(size)
        return createBuffer(size < 0 ? 0 : checked(size) | 0)
      }

      /**
       * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
       * */
      OwnBuffer.allocUnsafe = function (size) {
        return allocUnsafe(size)
      }
      /**
       * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
       */
      OwnBuffer.allocUnsafeSlow = function (size) {
        return allocUnsafe(size)
      }

      function fromString (string, encoding) {
        if (typeof encoding !== 'string' || encoding === '') {
          encoding = 'utf8'
        }

        if (!OwnBuffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }

        const length = byteLength(string, encoding) | 0
        let buf = createBuffer(length)

        const actual = buf.write(string, encoding)

        if (actual !== length) {
          // Writing a hex string, for example, that contains invalid characters will
          // cause everything after the first invalid character to be ignored. (e.g.
          // 'abxxcd' will be treated as 'ab')
          buf = buf.slice(0, actual)
        }

        return buf
      }

      function fromArrayLike (array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0
        const buf = createBuffer(length)
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255
        }
        return buf
      }

      function fromArrayView (arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView)
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
        }
        return fromArrayLike(arrayView)
      }

      function fromArrayBuffer (array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds')
        }

        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds')
        }

        let buf
        if (byteOffset === undefined && length === undefined) {
          buf = new Uint8Array(array)
        } else if (length === undefined) {
          buf = new Uint8Array(array, byteOffset)
        } else {
          buf = new Uint8Array(array, byteOffset, length)
        }

        // Return an augmented `Uint8Array` instance
        Object.setPrototypeOf(buf, OwnBuffer.prototype)

        return buf
      }

      function fromObject (obj) {
        if (OwnBuffer.isBuffer(obj)) {
          const len = checked(obj.length) | 0
          const buf = createBuffer(len)

          if (buf.length === 0) {
            return buf
          }

          obj.copy(buf, 0, 0, len)
          return buf
        }

        if (obj.length !== undefined) {
          if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
            return createBuffer(0)
          }
          return fromArrayLike(obj)
        }

        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data)
        }
      }

      function checked (length) {
        // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
        // length is NaN (which is otherwise coerced to zero.)
        if (length >= K_MAX_LENGTH) {
          throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                              'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
        }
        return length | 0
      }

      function SlowBuffer (length) {
        if (+length != length) { // eslint-disable-line eqeqeq
          length = 0
        }
        return OwnBuffer.alloc(+length)
      }

      OwnBuffer.isBuffer = function isBuffer (b) {
        return b != null && b._isBuffer === true &&
          b !== OwnBuffer.prototype // so OwnBuffer.isBuffer(OwnBuffer.prototype) will be false
      }

      OwnBuffer.compare = function compare (a, b) {
        if (isInstance(a, Uint8Array)) a = OwnBuffer.from(a, a.offset, a.byteLength)
        if (isInstance(b, Uint8Array)) b = OwnBuffer.from(b, b.offset, b.byteLength)
        if (!OwnBuffer.isBuffer(a) || !OwnBuffer.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          )
        }

        if (a === b) return 0

        let x = a.length
        let y = b.length

        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i]
            y = b[i]
            break
          }
        }

        if (x < y) return -1
        if (y < x) return 1
        return 0
      }

      OwnBuffer.isEncoding = function isEncoding (encoding) {
        switch (String(encoding).toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'latin1':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return true
          default:
            return false
        }
      }

      OwnBuffer.concat = function concat (list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }

        if (list.length === 0) {
          return OwnBuffer.alloc(0)
        }

        let i
        if (length === undefined) {
          length = 0
          for (i = 0; i < list.length; ++i) {
            length += list[i].length
          }
        }

        const buffer = OwnBuffer.allocUnsafe(length)
        let pos = 0
        for (i = 0; i < list.length; ++i) {
          let buf = list[i]
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > OwnBuffer.length) {
              if (!OwnBuffer.isBuffer(buf)) buf = OwnBuffer.from(buf)
              buf.copy(buffer, pos)
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              )
            }
          } else if (!OwnBuffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          } else {
            buf.copy(buffer, pos)
          }
          pos += buf.length
        }
        return buffer
      }

      function byteLength (string, encoding) {
        if (OwnBuffer.isBuffer(string)) {
          return string.length
        }
        if (ArrayOwnBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength
        }
        if (typeof string !== 'string') {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayOwnBuffer. ' +
            'Received type ' + typeof string
          )
        }

        const len = string.length
        const mustMatch = (arguments.length > 2 && arguments[2] === true)
        if (!mustMatch && len === 0) return 0

        // Use a for loop to avoid recursion
        let loweredCase = false
        for (;;) {
          switch (encoding) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return len
            case 'utf8':
            case 'utf-8':
              return utf8ToBytes(string).length
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return len * 2
            case 'hex':
              return len >>> 1
            case 'base64':
              return base64ToBytes(string).length
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
              }
              encoding = ('' + encoding).toLowerCase()
              loweredCase = true
          }
        }
      }
      OwnBuffer.byteLength = byteLength

      function slowToString (encoding, start, end) {
        let loweredCase = false

        // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
        // property of a typed array.

        // This behaves neither like String nor Uint8Array in that we set start/end
        // to their upper/lower bounds if the value passed is out of range.
        // undefined is handled specially as per ECMA-262 6th Edition,
        // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
        if (start === undefined || start < 0) {
          start = 0
        }
        // Return early if start > this.length. Done here to prevent potential uint32
        // coercion fail below.
        if (start > this.length) {
          return ''
        }

        if (end === undefined || end > this.length) {
          end = this.length
        }

        if (end <= 0) {
          return ''
        }

        // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
        end >>>= 0
        start >>>= 0

        if (end <= start) {
          return ''
        }

        if (!encoding) encoding = 'utf8'

        while (true) {
          switch (encoding) {
            case 'hex':
              return hexSlice(this, start, end)

            case 'utf8':
            case 'utf-8':
              return utf8Slice(this, start, end)

            case 'ascii':
              return asciiSlice(this, start, end)

            case 'latin1':
            case 'binary':
              return latin1Slice(this, start, end)

            case 'base64':
              return base64Slice(this, start, end)

            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return utf16leSlice(this, start, end)

            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
              encoding = (encoding + '').toLowerCase()
              loweredCase = true
          }
        }
      }

      // This property is used by `OwnBuffer.isBuffer` (and the `is-buffer` npm package)
      // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
      // reliably in a browserify context because there could be multiple different
      // copies of the 'buffer' package in use. This method works even for Buffer
      // instances that were created from another copy of the `buffer` package.
      // See: https://github.com/feross/buffer/issues/154
      OwnBuffer.prototype._isBuffer = true

      function swap (b, n, m) {
        const i = b[n]
        b[n] = b[m]
        b[m] = i
      }

      OwnBuffer.prototype.swap16 = function swap16 () {
        const len = this.length
        if (len % 2 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 16-bits')
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1)
        }
        return this
      }

      OwnBuffer.prototype.swap32 = function swap32 () {
        const len = this.length
        if (len % 4 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 32-bits')
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3)
          swap(this, i + 1, i + 2)
        }
        return this
      }

      OwnBuffer.prototype.swap64 = function swap64 () {
        const len = this.length
        if (len % 8 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 64-bits')
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7)
          swap(this, i + 1, i + 6)
          swap(this, i + 2, i + 5)
          swap(this, i + 3, i + 4)
        }
        return this
      }

      OwnBuffer.prototype.toString = function toString () {
        const length = this.length
        if (length === 0) return ''
        if (arguments.length === 0) return utf8Slice(this, 0, length)
        return slowToString.apply(this, arguments)
      }

      OwnBuffer.prototype.toLocaleString = OwnBuffer.prototype.toString

      OwnBuffer.prototype.equals = function equals (b) {
        if (!OwnBuffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
        if (this === b) return true
        return OwnBuffer.compare(this, b) === 0
      }

      OwnBuffer.prototype.inspect = function inspect () {
        let str = ''
        const max = INSPECT_MAX_BYTES
        str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
        if (this.length > max) str += ' ... '
        return '<Buffer ' + str + '>'
      }
      if (customInspectSymbol) {
        OwnBuffer.prototype[customInspectSymbol] = OwnBuffer.prototype.inspect
      }

      OwnBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = OwnBuffer.from(target, target.offset, target.byteLength)
        }
        if (!OwnBuffer.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. ' +
            'Received type ' + (typeof target)
          )
        }

        if (start === undefined) {
          start = 0
        }
        if (end === undefined) {
          end = target ? target.length : 0
        }
        if (thisStart === undefined) {
          thisStart = 0
        }
        if (thisEnd === undefined) {
          thisEnd = this.length
        }

        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError('out of range index')
        }

        if (thisStart >= thisEnd && start >= end) {
          return 0
        }
        if (thisStart >= thisEnd) {
          return -1
        }
        if (start >= end) {
          return 1
        }

        start >>>= 0
        end >>>= 0
        thisStart >>>= 0
        thisEnd >>>= 0

        if (this === target) return 0

        let x = thisEnd - thisStart
        let y = end - start
        const len = Math.min(x, y)

        const thisCopy = this.slice(thisStart, thisEnd)
        const targetCopy = target.slice(start, end)

        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i]
            y = targetCopy[i]
            break
          }
        }

        if (x < y) return -1
        if (y < x) return 1
        return 0
      }

      // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
      // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
      //
      // Arguments:
      // - buffer - a Buffer to search
      // - val - a string, Buffer, or number
      // - byteOffset - an index into `buffer`; will be clamped to an int32
      // - encoding - an optional encoding, relevant is val is a string
      // - dir - true for indexOf, false for lastIndexOf
      function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
        // Empty buffer means no match
        if (OwnBuffer.length === 0) return -1

        // Normalize byteOffset
        if (typeof byteOffset === 'string') {
          encoding = byteOffset
          byteOffset = 0
        } else if (byteOffset > 0x7fffffff) {
          byteOffset = 0x7fffffff
        } else if (byteOffset < -0x80000000) {
          byteOffset = -0x80000000
        }
        byteOffset = +byteOffset // Coerce to Number.
        if (numberIsNaN(byteOffset)) {
          // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
          byteOffset = dir ? 0 : (OwnBuffer.length - 1)
        }

        // Normalize byteOffset: negative offsets start from the end of the buffer
        if (byteOffset < 0) byteOffset = OwnBuffer.length + byteOffset
        if (byteOffset >= OwnBuffer.length) {
          if (dir) return -1
          else byteOffset = OwnBuffer.length - 1
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0
          else return -1
        }

        // Normalize val
        if (typeof val === 'string') {
          val = OwnBuffer.from(val, encoding)
        }

        // Finally, search either indexOf (if dir is true) or lastIndexOf
        if (OwnBuffer.isBuffer(val)) {
          // Special case: looking for empty string/buffer always fails
          if (val.length === 0) {
            return -1
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
        } else if (typeof val === 'number') {
          val = val & 0xFF // Search for a byte value [0-255]
          if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
        }

        throw new TypeError('val must be string, number or Buffer')
      }

      function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
        let indexSize = 1
        let arrLength = arr.length
        let valLength = val.length

        if (encoding !== undefined) {
          encoding = String(encoding).toLowerCase()
          if (encoding === 'ucs2' || encoding === 'ucs-2' ||
              encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
              return -1
            }
            indexSize = 2
            arrLength /= 2
            valLength /= 2
            byteOffset /= 2
          }
        }

        function read (buf, i) {
          if (indexSize === 1) {
            return buf[i]
          } else {
            return buf.readUInt16BE(i * indexSize)
          }
        }

        let i
        if (dir) {
          let foundIndex = -1
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
            } else {
              if (foundIndex !== -1) i -= i - foundIndex
              foundIndex = -1
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
          for (i = byteOffset; i >= 0; i--) {
            let found = true
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false
                break
              }
            }
            if (found) return i
          }
        }

        return -1
      }

      OwnBuffer.prototype.includes = function includes (val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1
      }

      OwnBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
      }

      OwnBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
      }

      function hexWrite (buf, string, offset, length) {
        offset = Number(offset) || 0
        const remaining = buf.length - offset
        if (!length) {
          length = remaining
        } else {
          length = Number(length)
          if (length > remaining) {
            length = remaining
          }
        }

        const strLen = string.length

        if (length > strLen / 2) {
          length = strLen / 2
        }
        let i
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16)
          if (numberIsNaN(parsed)) return i
          buf[offset + i] = parsed
        }
        return i
      }

      function utf8Write (buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
      }

      function asciiWrite (buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length)
      }

      function base64Write (buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length)
      }

      function ucs2Write (buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
      }

      OwnBuffer.prototype.write = function write (string, offset, length, encoding) {
        // Buffer#write(string)
        if (offset === undefined) {
          encoding = 'utf8'
          length = this.length
          offset = 0
        // Buffer#write(string, encoding)
        } else if (length === undefined && typeof offset === 'string') {
          encoding = offset
          length = this.length
          offset = 0
        // Buffer#write(string, offset[, length][, encoding])
        } else if (isFinite(offset)) {
          offset = offset >>> 0
          if (isFinite(length)) {
            length = length >>> 0
            if (encoding === undefined) encoding = 'utf8'
          } else {
            encoding = length
            length = undefined
          }
        } else {
          throw new Error(
            'OwnBuffer.write(string, encoding, offset[, length]) is no longer supported'
          )
        }

        const remaining = this.length - offset
        if (length === undefined || length > remaining) length = remaining

        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
          throw new RangeError('Attempt to write outside buffer bounds')
        }

        if (!encoding) encoding = 'utf8'

        let loweredCase = false
        for (;;) {
          switch (encoding) {
            case 'hex':
              return hexWrite(this, string, offset, length)

            case 'utf8':
            case 'utf-8':
              return utf8Write(this, string, offset, length)

            case 'ascii':
            case 'latin1':
            case 'binary':
              return asciiWrite(this, string, offset, length)

            case 'base64':
              // Warning: maxLength not taken into account in base64Write
              return base64Write(this, string, offset, length)

            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return ucs2Write(this, string, offset, length)

            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
              encoding = ('' + encoding).toLowerCase()
              loweredCase = true
          }
        }
      }

      OwnBuffer.prototype.toJSON = function toJSON () {
        return {
          type: 'Buffer',
          data: Array.prototype.slice.call(this._arr || this, 0)
        }
      }

      function base64Slice (buf, start, end) {
        if (start === 0 && end === buf.length) {
          return fromByteArray(buf)
        } else {
          return fromByteArray(buf.slice(start, end))
        }
      }

      function utf8Slice (buf, start, end) {
        end = Math.min(buf.length, end)
        const res = []

        let i = start
        while (i < end) {
          const firstByte = buf[i]
          let codePoint = null
          let bytesPerSequence = (firstByte > 0xEF)
            ? 4
            : (firstByte > 0xDF)
                ? 3
                : (firstByte > 0xBF)
                    ? 2
                    : 1

          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint

            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 0x80) {
                  codePoint = firstByte
                }
                break
              case 2:
                secondByte = buf[i + 1]
                if ((secondByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                  if (tempCodePoint > 0x7F) {
                    codePoint = tempCodePoint
                  }
                }
                break
              case 3:
                secondByte = buf[i + 1]
                thirdByte = buf[i + 2]
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                    codePoint = tempCodePoint
                  }
                }
                break
              case 4:
                secondByte = buf[i + 1]
                thirdByte = buf[i + 2]
                fourthByte = buf[i + 3]
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                    codePoint = tempCodePoint
                  }
                }
            }
          }

          if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD
            bytesPerSequence = 1
          } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000
            res.push(codePoint >>> 10 & 0x3FF | 0xD800)
            codePoint = 0xDC00 | codePoint & 0x3FF
          }

          res.push(codePoint)
          i += bytesPerSequence
        }

        return decodeCodePointsArray(res)
      }

      // Based on http://stackoverflow.com/a/22747272/680742, the browser with
      // the lowest limit is Chrome, with 0x10000 args.
      // We go 1 magnitude less, for safety
      const MAX_ARGUMENTS_LENGTH = 0x1000

      function decodeCodePointsArray (codePoints) {
        const len = codePoints.length
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
        }

        // Decode in chunks to avoid "call stack size exceeded".
        let res = ''
        let i = 0
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          )
        }
        return res
      }

      function asciiSlice (buf, start, end) {
        let ret = ''
        end = Math.min(buf.length, end)

        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 0x7F)
        }
        return ret
      }

      function latin1Slice (buf, start, end) {
        let ret = ''
        end = Math.min(buf.length, end)

        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i])
        }
        return ret
      }

      function hexSlice (buf, start, end) {
        const len = buf.length

        if (!start || start < 0) start = 0
        if (!end || end < 0 || end > len) end = len

        let out = ''
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]]
        }
        return out
      }

      function utf16leSlice (buf, start, end) {
        const bytes = buf.slice(start, end)
        let res = ''
        // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
        }
        return res
      }

      OwnBuffer.prototype.slice = function slice (start, end) {
        const len = this.length
        start = ~~start
        end = end === undefined ? len : ~~end

        if (start < 0) {
          start += len
          if (start < 0) start = 0
        } else if (start > len) {
          start = len
        }

        if (end < 0) {
          end += len
          if (end < 0) end = 0
        } else if (end > len) {
          end = len
        }

        if (end < start) end = start

        const newBuf = this.subarray(start, end)
        // Return an augmented `Uint8Array` instance
        Object.setPrototypeOf(newBuf, OwnBuffer.prototype)

        return newBuf
      }

      /*
      * Need to make sure that buffer isn't trying to write out of bounds.
      */
      function checkOffset (offset, ext, length) {
        if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
      }

      OwnBuffer.prototype.readUintLE =
      OwnBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)

        let val = this[offset]
        let mul = 1
        let i = 0
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul
        }

        return val
      }

      OwnBuffer.prototype.readUintBE =
      OwnBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert) {
          checkOffset(offset, byteLength, this.length)
        }

        let val = this[offset + --byteLength]
        let mul = 1
        while (byteLength > 0 && (mul *= 0x100)) {
          val += this[offset + --byteLength] * mul
        }

        return val
      }

      OwnBuffer.prototype.readUint8 =
      OwnBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 1, this.length)
        return this[offset]
      }

      OwnBuffer.prototype.readUint16LE =
      OwnBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 2, this.length)
        return this[offset] | (this[offset + 1] << 8)
      }

      OwnBuffer.prototype.readUint16BE =
      OwnBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 2, this.length)
        return (this[offset] << 8) | this[offset + 1]
      }

      OwnBuffer.prototype.readUint32LE =
      OwnBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 4, this.length)

        return ((this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16)) +
            (this[offset + 3] * 0x1000000)
      }

      OwnBuffer.prototype.readUint32BE =
      OwnBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 4, this.length)

        return (this[offset] * 0x1000000) +
          ((this[offset + 1] << 16) |
          (this[offset + 2] << 8) |
          this[offset + 3])
      }

      OwnBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
        offset = offset >>> 0
        validateNumber(offset, 'offset')
        const first = this[offset]
        const last = this[offset + 7]
        if (first === undefined || last === undefined) {
          boundsError(offset, this.length - 8)
        }

        const lo = first +
          this[++offset] * 2 ** 8 +
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 24

        const hi = this[++offset] +
          this[++offset] * 2 ** 8 +
          this[++offset] * 2 ** 16 +
          last * 2 ** 24

        return BigInt(lo) + (BigInt(hi) << BigInt(32))
      })

      OwnBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
        offset = offset >>> 0
        validateNumber(offset, 'offset')
        const first = this[offset]
        const last = this[offset + 7]
        if (first === undefined || last === undefined) {
          boundsError(offset, this.length - 8)
        }

        const hi = first * 2 ** 24 +
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 8 +
          this[++offset]

        const lo = this[++offset] * 2 ** 24 +
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 8 +
          last

        return (BigInt(hi) << BigInt(32)) + BigInt(lo)
      })

      OwnBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)

        let val = this[offset]
        let mul = 1
        let i = 0
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul
        }
        mul *= 0x80

        if (val >= mul) val -= Math.pow(2, 8 * byteLength)

        return val
      }

      OwnBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)

        let i = byteLength
        let mul = 1
        let val = this[offset + --i]
        while (i > 0 && (mul *= 0x100)) {
          val += this[offset + --i] * mul
        }
        mul *= 0x80

        if (val >= mul) val -= Math.pow(2, 8 * byteLength)

        return val
      }

      OwnBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 1, this.length)
        if (!(this[offset] & 0x80)) return (this[offset])
        return ((0xff - this[offset] + 1) * -1)
      }

      OwnBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 2, this.length)
        const val = this[offset] | (this[offset + 1] << 8)
        return (val & 0x8000) ? val | 0xFFFF0000 : val
      }

      OwnBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 2, this.length)
        const val = this[offset + 1] | (this[offset] << 8)
        return (val & 0x8000) ? val | 0xFFFF0000 : val
      }

      OwnBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 4, this.length)

        return (this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16) |
          (this[offset + 3] << 24)
      }

      OwnBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 4, this.length)

        return (this[offset] << 24) |
          (this[offset + 1] << 16) |
          (this[offset + 2] << 8) |
          (this[offset + 3])
      }

      OwnBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
        offset = offset >>> 0
        validateNumber(offset, 'offset')
        const first = this[offset]
        const last = this[offset + 7]
        if (first === undefined || last === undefined) {
          boundsError(offset, this.length - 8)
        }

        const val = this[offset + 4] +
          this[offset + 5] * 2 ** 8 +
          this[offset + 6] * 2 ** 16 +
          (last << 24) // Overflow

        return (BigInt(val) << BigInt(32)) +
          BigInt(first +
          this[++offset] * 2 ** 8 +
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 24)
      })

      OwnBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
        offset = offset >>> 0
        validateNumber(offset, 'offset')
        const first = this[offset]
        const last = this[offset + 7]
        if (first === undefined || last === undefined) {
          boundsError(offset, this.length - 8)
        }

        const val = (first << 24) + // Overflow
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 8 +
          this[++offset]

        return (BigInt(val) << BigInt(32)) +
          BigInt(this[++offset] * 2 ** 24 +
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 8 +
          last)
      })

      OwnBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 4, this.length)
        return ieee754Read(this, offset, true, 23, 4)
      }

      OwnBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 4, this.length)
        return ieee754Read(this, offset, false, 23, 4)
      }

      OwnBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 8, this.length)
        return ieee754Read(this, offset, true, 52, 8)
      }

      OwnBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
        offset = offset >>> 0
        if (!noAssert) checkOffset(offset, 8, this.length)
        return ieee754Read(this, offset, false, 52, 8)
      }

      function checkInt (buf, value, offset, ext, max, min) {
        if (!OwnBuffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
        if (offset + ext > buf.length) throw new RangeError('Index out of range')
      }

      OwnBuffer.prototype.writeUintLE =
      OwnBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength) - 1
          checkInt(this, value, offset, byteLength, maxBytes, 0)
        }

        let mul = 1
        let i = 0
        this[offset] = value & 0xFF
        while (++i < byteLength && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF
        }

        return offset + byteLength
      }

      OwnBuffer.prototype.writeUintBE =
      OwnBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength) - 1
          checkInt(this, value, offset, byteLength, maxBytes, 0)
        }

        let i = byteLength - 1
        let mul = 1
        this[offset + i] = value & 0xFF
        while (--i >= 0 && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF
        }

        return offset + byteLength
      }

      OwnBuffer.prototype.writeUint8 =
      OwnBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
        this[offset] = (value & 0xff)
        return offset + 1
      }

      OwnBuffer.prototype.writeUint16LE =
      OwnBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
        return offset + 2
      }

      OwnBuffer.prototype.writeUint16BE =
      OwnBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
        return offset + 2
      }

      OwnBuffer.prototype.writeUint32LE =
      OwnBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
        this[offset + 3] = (value >>> 24)
        this[offset + 2] = (value >>> 16)
        this[offset + 1] = (value >>> 8)
        this[offset] = (value & 0xff)
        return offset + 4
      }

      OwnBuffer.prototype.writeUint32BE =
      OwnBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
        return offset + 4
      }

      function wrtBigUInt64LE (buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7)

        let lo = Number(value & BigInt(0xffffffff))
        buf[offset++] = lo
        lo = lo >> 8
        buf[offset++] = lo
        lo = lo >> 8
        buf[offset++] = lo
        lo = lo >> 8
        buf[offset++] = lo
        let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
        buf[offset++] = hi
        hi = hi >> 8
        buf[offset++] = hi
        hi = hi >> 8
        buf[offset++] = hi
        hi = hi >> 8
        buf[offset++] = hi
        return offset
      }

      function wrtBigUInt64BE (buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7)

        let lo = Number(value & BigInt(0xffffffff))
        buf[offset + 7] = lo
        lo = lo >> 8
        buf[offset + 6] = lo
        lo = lo >> 8
        buf[offset + 5] = lo
        lo = lo >> 8
        buf[offset + 4] = lo
        let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
        buf[offset + 3] = hi
        hi = hi >> 8
        buf[offset + 2] = hi
        hi = hi >> 8
        buf[offset + 1] = hi
        hi = hi >> 8
        buf[offset] = hi
        return offset + 8
      }

      OwnBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
      })

      OwnBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
      })

      OwnBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) {
          const limit = Math.pow(2, (8 * byteLength) - 1)

          checkInt(this, value, offset, byteLength, limit - 1, -limit)
        }

        let i = 0
        let mul = 1
        let sub = 0
        this[offset] = value & 0xFF
        while (++i < byteLength && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1
          }
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
        }

        return offset + byteLength
      }

      OwnBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) {
          const limit = Math.pow(2, (8 * byteLength) - 1)

          checkInt(this, value, offset, byteLength, limit - 1, -limit)
        }

        let i = byteLength - 1
        let mul = 1
        let sub = 0
        this[offset + i] = value & 0xFF
        while (--i >= 0 && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1
          }
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
        }

        return offset + byteLength
      }

      OwnBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
        if (value < 0) value = 0xff + value + 1
        this[offset] = (value & 0xff)
        return offset + 1
      }

      OwnBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
        return offset + 2
      }

      OwnBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
        return offset + 2
      }

      OwnBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
        this[offset + 2] = (value >>> 16)
        this[offset + 3] = (value >>> 24)
        return offset + 4
      }

      OwnBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
        if (value < 0) value = 0xffffffff + value + 1
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
        return offset + 4
      }

      OwnBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
      })

      OwnBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
      })

      function checkIEEE754 (buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError('Index out of range')
        if (offset < 0) throw new RangeError('Index out of range')
      }

      function writeFloat (buf, value, offset, littleEndian, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
        }
        ieee754Write(buf, value, offset, littleEndian, 23, 4)
        return offset + 4
      }

      OwnBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert)
      }

      OwnBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert)
      }

      function writeDouble (buf, value, offset, littleEndian, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
        }
        ieee754Write(buf, value, offset, littleEndian, 52, 8)
        return offset + 8
      }

      OwnBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert)
      }

      OwnBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert)
      }

      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=OwnBuffer.length)
      OwnBuffer.prototype.copy = function copy (target, targetStart, start, end) {
        if (!OwnBuffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
        if (!start) start = 0
        if (!end && end !== 0) end = this.length
        if (targetStart >= target.length) targetStart = target.length
        if (!targetStart) targetStart = 0
        if (end > 0 && end < start) end = start

        // Copy 0 bytes; we're done
        if (end === start) return 0
        if (target.length === 0 || this.length === 0) return 0

        // Fatal error conditions
        if (targetStart < 0) {
          throw new RangeError('targetStart out of bounds')
        }
        if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
        if (end < 0) throw new RangeError('sourceEnd out of bounds')

        // Are we oob?
        if (end > this.length) end = this.length
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start
        }

        const len = end - start

        if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
          // Use built-in when available, missing from IE11
          this.copyWithin(targetStart, start, end)
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          )
        }

        return len
      }

      // Usage:
      //    OwnBuffer.fill(number[, offset[, end]])
      //    OwnBuffer.fill(buffer[, offset[, end]])
      //    OwnBuffer.fill(string[, offset[, end]][, encoding])
      OwnBuffer.prototype.fill = function fill (val, start, end, encoding) {
        // Handle string cases:
        if (typeof val === 'string') {
          if (typeof start === 'string') {
            encoding = start
            start = 0
            end = this.length
          } else if (typeof end === 'string') {
            encoding = end
            end = this.length
          }
          if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string')
          }
          if (typeof encoding === 'string' && !OwnBuffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding)
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0)
            if ((encoding === 'utf8' && code < 128) ||
                encoding === 'latin1') {
              // Fast path: If `val` fits into a single byte, use that numeric value.
              val = code
            }
          }
        } else if (typeof val === 'number') {
          val = val & 255
        } else if (typeof val === 'boolean') {
          val = Number(val)
        }

        // Invalid ranges are not set to a default, so can range check early.
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError('Out of range index')
        }

        if (end <= start) {
          return this
        }

        start = start >>> 0
        end = end === undefined ? this.length : end >>> 0

        if (!val) val = 0

        let i
        if (typeof val === 'number') {
          for (i = start; i < end; ++i) {
            this[i] = val
          }
        } else {
          const bytes = OwnBuffer.isBuffer(val)
            ? val
            : OwnBuffer.from(val, encoding)
          const len = bytes.length
          if (len === 0) {
            throw new TypeError('The value "' + val +
              '" is invalid for argument "value"')
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len]
          }
        }

        return this
      }

      // CUSTOM ERRORS
      // =============

      // Simplified versions from Node, changed for Buffer-only usage
      const errors = {}
      function E (sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor () {
            super()

            Object.defineProperty(this, 'message', {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            })

            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            // Reset the name to the actual name.
            delete this.name
          }

          get code () {
            return sym
          }

          set code (value) {
            Object.defineProperty(this, 'code', {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            })
          }

          toString () {
            return `${this.name} [${sym}]: ${this.message}`
          }
        }
      }

      E('ERR_BUFFER_OUT_OF_BOUNDS',
        function (name) {
          if (name) {
            return `${name} is outside of buffer bounds`
          }

          return 'Attempt to access memory outside buffer bounds'
        }, RangeError)
      E('ERR_INVALID_ARG_TYPE',
        function (name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`
        }, TypeError)
      E('ERR_OUT_OF_RANGE',
        function (str, range, input) {
          let msg = `The value of "${str}" is out of range.`
          let received = input
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input))
          } else if (typeof input === 'bigint') {
            received = String(input)
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received)
            }
            received += 'n'
          }
          msg += ` It must be ${range}. Received ${received}`
          return msg
        }, RangeError)

      function addNumericalSeparator (val) {
        let res = ''
        let i = val.length
        const start = val[0] === '-' ? 1 : 0
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`
        }
        return `${val.slice(0, i)}${res}`
      }

      // CHECK FUNCTIONS
      // ===============

      function checkBounds (buf, offset, byteLength) {
        validateNumber(offset, 'offset')
        if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
          boundsError(offset, buf.length - (byteLength + 1))
        }
      }

      function checkIntBI (value, min, max, buf, offset, byteLength) {
        if (value > max || value < min) {
          const n = typeof min === 'bigint' ? 'n' : ''
          let range
          if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
            } else {
              range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                      `${(byteLength + 1) * 8 - 1}${n}`
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`
          }
          throw new errors.ERR_OUT_OF_RANGE('value', range, value)
        }
        checkBounds(buf, offset, byteLength)
      }

      function validateNumber (value, name) {
        if (typeof value !== 'number') {
          throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
        }
      }

      function boundsError (value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type)
          throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
        }

        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
        }

        throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                          `>= ${type ? 1 : 0} and <= ${length}`,
                                          value)
      }

      // HELPER FUNCTIONS
      // ================

      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

      function base64clean (str) {
        // Node takes equal signs as end of the Base64 encoding
        str = str.split('=')[0]
        // Node strips out invalid characters like \n and \t from the string, base64-js does not
        str = str.trim().replace(INVALID_BASE64_RE, '')
        // Node converts strings with length < 2 to ''
        if (str.length < 2) return ''
        // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
        while (str.length % 4 !== 0) {
          str = str + '='
        }
        return str
      }

      function utf8ToBytes (string, units) {
        units = units || Infinity
        let codePoint
        const length = string.length
        let leadSurrogate = null
        const bytes = []

        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i)

          // is surrogate component
          if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
              // no lead yet
              if (codePoint > 0xDBFF) {
                // unexpected trail
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                continue
              } else if (i + 1 === length) {
                // unpaired lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                continue
              }

              // valid lead
              leadSurrogate = codePoint

              continue
            }

            // 2 leads in a row
            if (codePoint < 0xDC00) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              leadSurrogate = codePoint
              continue
            }

            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
          } else if (leadSurrogate) {
            // valid bmp char, but last char was a lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          }

          leadSurrogate = null

          // encode utf8
          if (codePoint < 0x80) {
            if ((units -= 1) < 0) break
            bytes.push(codePoint)
          } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break
            bytes.push(
              codePoint >> 0x6 | 0xC0,
              codePoint & 0x3F | 0x80
            )
          } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break
            bytes.push(
              codePoint >> 0xC | 0xE0,
              codePoint >> 0x6 & 0x3F | 0x80,
              codePoint & 0x3F | 0x80
            )
          } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break
            bytes.push(
              codePoint >> 0x12 | 0xF0,
              codePoint >> 0xC & 0x3F | 0x80,
              codePoint >> 0x6 & 0x3F | 0x80,
              codePoint & 0x3F | 0x80
            )
          } else {
            throw new Error('Invalid code point')
          }
        }

        return bytes
      }

      function asciiToBytes (str) {
        const byteArray = []
        for (let i = 0; i < str.length; ++i) {
          // Node's code seems to be doing this and not & 0x7F..
          byteArray.push(str.charCodeAt(i) & 0xFF)
        }
        return byteArray
      }

      function utf16leToBytes (str, units) {
        let c, hi, lo
        const byteArray = []
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break

          c = str.charCodeAt(i)
          hi = c >> 8
          lo = c % 256
          byteArray.push(lo)
          byteArray.push(hi)
        }

        return byteArray
      }

      function base64ToBytes (str) {
        return toByteArray(base64clean(str))
      }

      function blitBuffer (src, dst, offset, length) {
        let i
        for (i = 0; i < length; ++i) {
          if ((i + offset >= dst.length) || (i >= src.length)) break
          dst[i + offset] = src[i]
        }
        return i
      }

      // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
      // the `instanceof` check but they should be treated as of that type.
      // See: https://github.com/feross/buffer/issues/166
      function isInstance (obj, type) {
        return obj instanceof type ||
          (obj != null && obj.constructor != null && obj.constructor.name != null &&
            obj.constructor.name === type.name)
      }
      function numberIsNaN (obj) {
        // For IE11 support
        return obj !== obj // eslint-disable-line no-self-compare
      }

      // Create lookup table for `toString('hex')`
      // See: https://github.com/feross/buffer/issues/219
      const hexSliceLookupTable = (function () {
        const alphabet = '0123456789abcdef'
        const table = new Array(256)
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j]
          }
        }
        return table
      })()

      // Return not function with Error if BigInt not supported
      function defineBigIntMethod (fn) {
        return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
      }

      function BufferBigIntNotDefined () {
        throw new Error('BigInt not supported')
      }

      // Use window.Buffer for bn.js package in bitcore-lib
      if (window) {
        window.Buffer = OwnBuffer
      }
    </script>


    <!--
      * Please use only one inline script in this file (each additional script requires an additional hash in the extension manifest).

      * Each change to this script requires a hash change in the extension manifest.
    -->

    <script>
      // Extension: prevent 2 tabs
      if (window.chrome && window.chrome.extension) {
        var extViews = chrome.extension.getViews()
        var extBgWindow = chrome.extension.getBackgroundPage()
        if (window !== extBgWindow) {
          if (chrome.extension.getViews().length > 2) {
            chrome.runtime.openOptionsPage()
            window.close()
          }
          window.onbeforeunload = () => {
            // With this window and bg window = 2
            if (chrome.extension.getViews().length === 2) {
              extBgWindow.location.reload()
            }
          }
        }
      }

      // Extension: icon click => open tab
      if (window.chrome && window.chrome.browserAction) {
        if (!chrome.browserAction.isClickListenerAdded) {
          console.log('Extension: add click listener')
          chrome.browserAction.onClicked.addListener(function(tab) {
            console.log('Extension: icon clicked')
            chrome.runtime.openOptionsPage()
          });
          chrome.browserAction.isClickListenerAdded = true;
        } else {
          console.log('Extension: click listener already added');
        }
      } else {
        console.log('Extension: can`t add click listener (possibly not extension)')
      }

      // Check caching backend
      try {
        JSON.parse("<!-- BACK_SO");
      } catch (e) {
        console.log("warning: caching backend is down")
      }

      let localStorageIsOk = true;
      try {
        const testLocalStorage = window.localStorage;
      } catch (e) {
        localStorageIsOk = false;
        document.getElementById('onFailLocalStorageLink').href = window.location.href;
        document.getElementById('onFailLocalStorageMessage').classList.remove('d-none');

        const sendErrorFeedback = function () {
          let msg = 'localStorage error: agent(' + navigator.userAgent + ')';
          msg += ', location(' + window.location.href + ')';

          let url = 'https://noxon.wpmix.net/counter.php?msg=' + encodeURI(msg);

          if (!window?.STATISTIC_DISABLED) {
            window.jQuery.ajax({
              type: 'POST',
              url: url,
            });
          }
        };

        if (!window.jQuery) {
          // inject jQuery for send request to counter for feedback
          let jsScriptTag = document.createElement('SCRIPT');
          jsScriptTag.src = 'https://code.jquery.com/jquery-3.5.1.min.js';
          console.log('jsScriptTag', jsScriptTag);
          document.getElementsByTagName('BODY')[0].appendChild(jsScriptTag);
          let waitJQLoad = function (onLoaded) {
            if (window.jQuery) {
              onLoaded();
            } else {
              window.setTimeout(function () {
                waitJQLoad(onLoaded);
              }, 100);
            }
          };
          waitJQLoad(sendErrorFeedback);
        } else {
          sendErrorFeedback();
        }
      }

      function setCookie(name, value, options = {}) {
        let expires = options.expires;

        if (typeof expires == 'number' && expires) {
          let date = new Date();
          date.setTime(date.getTime() + expires * 1000);
          expires = options.expires = date;
        }
        if (expires && expires.toUTCString) {
          options.expires = expires.toUTCString();
        }

        value = encodeURIComponent(value);
        let updatedCookie = name + '=' + value;

        for (let propName in options) {
          updatedCookie += '; ' + propName;
          const propValue = options[propName];

          if (propValue !== true) {
            updatedCookie += '=' + propValue;
          }
        }
        document.cookie = updatedCookie;
      }

      function getCookie(cookieName) {
        const name = cookieName + '=';
        const parametersArr = document.cookie.split(';');

        for (let i = 0; i < parametersArr.length; i++) {
          let parameter = parametersArr[i];
          while (parameter.charAt(0) == ' ') {
            parameter = parameter.substring(1);
          }
          if (parameter.indexOf(name) == 0) {
            return parameter.substring(name.length, parameter.length);
          }
        }
        return '';
      }

      const wrapper = document.getElementById('wrapper_element');

      if (window.localStorage.getItem('isDark')) {
        wrapper.classList.add('darkTheme');
      } else {
        wrapper.classList.remove('darkTheme');
      }

      // detect browser's lang
      const getNavigatorLanguage = () => {
        if (navigator.languages && navigator.languages.length) {
          return navigator.languages[0];
        } else {
          return (
            navigator.userLanguage ||
            navigator.language ||
            navigator.browserLanguage ||
            'en'
          );
        }
      };

      let lang = getCookie('mylang');

      if (!lang) {
        const browserLang = getNavigatorLanguage();
        lang = browserLang.includes('ru') ? 'ru' : 'en'
        setCookie('mylang', lang);
      }

      const locale = lang.toLowerCase();
      const locationName = lang.toUpperCase();

      (function () {
        // set tip
        const tips = {
          beforeBackup: [
            {
              en: 'Loading...',
              ru: 'Загрузка...',
            },
          ],
          afterBackup: [
            {
              en: 'Keep your recovery phrase in&nbsp;a&nbsp;safe place',
              ru: 'Держите вашу фразу восстановления в&nbsp;безопасном месте',
            },
            {
              en: "Don't forget where your recovery phrase is&nbsp;saved",
              ru: 'Не забудьте, где&nbsp;хранится ваша фраза восстановления',
            },
          ],
        };
        // Determine if the passphrase is saved
        if (locale === 'en' || locale === 'ru') {
          const mnemonic = window.localStorage.getItem('testnet:twentywords') || window.localStorage.getItem('mainnet:twentywords');
          const isBackup = mnemonic === `-`;
          const relevantTips = tips[!isBackup ? 'beforeBackup' : 'afterBackup'];
          const currentTip = relevantTips[Math.floor(Math.random() * relevantTips.length)][locale];
          const tipNode = document.getElementById('beforeJSTip');
          tipNode.innerHTML = currentTip;
        } else {
          console.error('Unknown locale', locale);
        }
      })();

      const information = document.getElementById('usersInform');

      if ((locationName === 'ru' || (locale === 'ru' && locationName !== 'en')) && localStorage.length === 0) {
        information.innerText = 'Генерация приватных ключей для вашего мультивалютного кошелька прямо сейчас, \n это может занять одну минуту'
      }

      if (localStorage.length === 0) {
        information.innerText =
          locationName !== 'ru' || locale !== 'ru'
            ? 'Please wait while the application is loading,\n it may take one minute...'
            : 'Пожалуйста подождите пока приложение запускается,\n это не займет больше минуты...';
      }


      window.prerenderReady = false;
      window.isUserRegisteredAndLoggedIn = false;
      window.DEFAULT_FIAT = 'USD';
      window.DefaultCountryCode = '+1';
      window.widgetName = 'own widget name';

      window.buyViaCreditCardLink = 'https://buy.itez.com/swaponline';

      /* /Loader before any JS */

      /* Start Modal Scripts */

      /**
       * For setCookie() function
       */
      const SEC_IN_HOUR = 60 * 60
      const SEC_IN_DAY = SEC_IN_HOUR * 24
      const SEC_IN_MONTH = SEC_IN_DAY * daysInThisMonth()
      const SEC_IN_YEAR = SEC_IN_MONTH * 12

      function daysInThisMonth() {
        const date = new Date()
        return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
      }

      function swapIsHome() {
        const swapLocationHash = window.location.hash;
        if (swapLocationHash == '' || swapLocationHash == '#/') {
          return true;
        }
        return false;
      }
     
      function swapIsWalletCreate() {
        const swapLocalStorageWallet = localStorage.getItem('isWalletCreate');
        return swapLocalStorageWallet !== null
      }

      // Swap Modal
      const startedSplashScreenIsDisabled = getCookie('startedSplashScreenIsDisabled');

      const isWidgetBuild = '<%= htmlWebpackPlugin.options.isWidget %>';
      const isBinanceBuild = ('<%= htmlWebpackPlugin.options.isBinanceBuild %>' === 'true') ? true : false;

      // Open modal if cookie false
      if (
        startedSplashScreenIsDisabled != 'true' &&
        swapIsHome() &&
        !isWidgetBuild &&
        !swapIsWalletCreate() &&
        !isBinanceBuild &&
        localStorageIsOk
      ) {
        document.getElementById('starter-modal').classList.remove('d-none');
      }

      const urlHash = window.location.hash
      const host = window.location.host

      const isHomePath = (urlHash === '#/' || urlHash === '#/createWallet' || urlHash === '' )

      if (host === 'bsc.swap.io' && isHomePath) {
        redirectionTo('#/exchange/btc-to-{BNB}btcb}')
      }

      if (host === 'matic.swap.io' && isHomePath) {
        redirectionTo('#/exchange/btc-to-{MATIC}wbtc')
      }

      const btnCreateWallet = document.getElementById('preloaderCreateBtn');
      const btnConnectWallet = document.getElementById('preloaderConnectBtn');
      const btnSkip = document.getElementById('preloaderSkipBtn');
      const btnRestoryWallet = document.getElementById('preloaderRestoreBtn');

      btnCreateWallet.addEventListener('click', function () {
        redirectionTo('#/createWallet')
      });

      btnConnectWallet.addEventListener('click', function () {
        redirectionTo('#/connectWallet')
      });

      btnRestoryWallet.addEventListener('click', function () {
        redirectionTo('#/restoreWallet')
      })

      btnSkip.addEventListener('click', function () {
        redirectionTo('#/exchange')
      });

      function redirectionTo(urlPath) {
        document.location.href = urlPath;
        document.getElementById('starter-modal').classList.add('d-none');

        setCookie('swapDisalbeStarter', 'true', {
          expires: SEC_IN_YEAR * 5,
        });
      }

      window.logoUrl = '#';
      window.darkLogoUrl = '';
      window.loaderLogoUrl = '';

      if (window.localStorage.getItem('isDark')) {
        window.logoUrl = window.darkLogoUrl || window.logoUrl;
      }

      if (
        window.location.hostname === "localhost" ||
        window.location.hostname === "swaponline.github.io" ||
        window.location.hostname === "swaponline.io"
      ) {
        // used by Loader component
        window.loaderLogoUrl = "https://wiki.swaponline.io/assets/swaponline_io.svg";
        document.getElementById("loaderImg").src = window.loaderLogoUrl;
      } else {
        if (window.logoUrl != '#') {
          document.getElementById("loaderImg").src = window.localStorage.getItem("isDark") ? window.darkLogoUrl : window.logoUrl;
        } else {
          document.getElementById("loaderImg").style.display = 'none'
        }
      }
      /* End Modal Scripts */


      /* Google Analytics */
      const isMainDomain = window.location.hostname === 'swaponline.io';
      const isExtension =
        window.location.hostname === 'jbhhiineefefhcaoocmnkbmgfjbhninc';

      if (isMainDomain || isExtension) {
        const gtagScript = document.createElement('script');
        var gtagId;

        if (isMainDomain) {
          gtagId = 'UA-116857031-2';
        }

        if (isExtension) {
          gtagId = 'GTM-PJH52QL';
        }

        gtagScript.async = true;
        gtagScript.src =
          'https://www.googletagmanager.com/gtag/js?id=' + gtagId;

        document.head.appendChild(gtagScript);

        window.dataLayer = window.dataLayer || [];

        window.gtag = function () {
          window.dataLayer.push(arguments);
        };

        gtag('js', new Date());
        gtag('config', gtagId);
      }
      /* End Google Analytics */
    </script>
  </body>
</html>
